/**
 * HaMienChatbot - Chatbot ch·ªâ d·ª±a tr√™n d·ªØ li·ªáu Intents v√† Entities
 * Version: 2.0 - Pure Intent/Entity Based
 */

class HaMienChatbot {
  constructor() {
    this.intents = {};
    this.entities = {};
    this.loaded = false;
    this.conversationContext = {
      currentIntent: null,
      currentEntities: {},
      conversationHistory: []
    };
    
    this.init();
  }

  async init() {
    console.log('ü§ñ Initializing HaMienChatbot...');
    
    // Load intents and entities data
    await this.loadIntentsAndEntities();
    
    // Setup event listeners
    this.setupEventListeners();
    
    // Show welcome message
    this.showWelcomeMessage();
    
    console.log('‚úÖ HaMienChatbot initialized successfully');
  }

  async loadIntentsAndEntities() {
    try {
      console.log('üìö Loading intents and entities...');
      
      // Load all intents
      await this.loadIntents();
      
      // Load all entities
      await this.loadEntities();
      
      this.loaded = true;
      console.log('‚úÖ Intents and entities loaded successfully');
      console.log(`üìä Loaded ${Object.keys(this.intents).length} intents and ${Object.keys(this.entities).length} entities`);
      
      // Debug: Check if TTworkshop intent is loaded
      if (this.intents['ituvan - dichvu - TTworkshop']) {
        console.log('‚úÖ TTworkshop intent loaded successfully');
        console.log('üìù TTworkshop response:', this.intents['ituvan - dichvu - TTworkshop'].responses?.[0]?.messages?.[0]?.speech?.[0]);
      } else {
        console.log('‚ùå TTworkshop intent NOT loaded');
      }
      
    } catch (error) {
      console.error('‚ùå Error loading intents and entities:', error);
    }
  }

  async loadIntents() {
    const intentFiles = [
      'ichaohoi', 'idathoa', 'ituvan', 'ituvan - sanpham', 'ituvan - dichvu',
      'ithongtinshop', 'iphiship', 'iPTTT', 'idealhot', 'ihuydon',
      'iketthuc', 'iphanhoitot', 'iphanhoixau', 'ithuthiep', 'itracuudonhang',
      'ituvan - dichvu - decorsukien', 'ituvan - dichvu - TGworkshop',
      'ituvan - dichvu - thietketheoyeucau', 'ituvan - dichvu - TTworkshop',
      'ituvan - sanpham - xemmau', 'Default Welcome Intent', 'Default Fallback Intent'
    ];

    for (const intentName of intentFiles) {
      try {
        const response = await fetch(`intents/${intentName}.json`);
        if (response.ok) {
          const intentData = await response.json();
          this.intents[intentName] = intentData;
          console.log(`‚úÖ Loaded intent: ${intentName}`);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Could not load intent: ${intentName}`, error);
      }
    }
  }

  async loadEntities() {
    const entityFiles = [
      'echaohoi', 'edathoa', 'esanpham', 'edichvu', 'etuvan', 'ehotline',
      'eloaihoa', 'emauhoa', 'esoluong', 'ephuongthucthanhtoan', 'enoiban',
      'enoidatmua', 'engaygio', 'edonhang', 'ehuydon', 'ecamon', 'ecacdip',
      'edealhot', 'emasanpham', 'ethuthiep', 'ephanhoitot', 'ephanhoixau'
    ];

    for (const entityName of entityFiles) {
      try {
        // Load entity definition
        const entityResponse = await fetch(`entities/${entityName}.json`);
        if (entityResponse.ok) {
          const entityData = await entityResponse.json();
          
          // Load entity entries
          const entriesResponse = await fetch(`entities/${entityName}_entries_vi.json`);
          if (entriesResponse.ok) {
            const entriesData = await entriesResponse.json();
            this.entities[entityName] = {
              ...entityData,
              entries: entriesData
            };
            console.log(`‚úÖ Loaded entity: ${entityName} with ${entriesData.length} entries`);
          }
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Could not load entity: ${entityName}`, error);
      }
    }
  }

  setupEventListeners() {
    // Chatbot button click to toggle chatbox
    const chatButton = document.getElementById("chatbot-button");
    if (chatButton) {
      chatButton.addEventListener("click", () => this.toggleChat());
    }

    // Close button click
    const closeButton = document.getElementById("chat-close");
    if (closeButton) {
      closeButton.addEventListener("click", () => this.toggleChat());
    }

    // Send message on Enter key
    document.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        this.sendMessage();
      }
    });

    // Send message button click
    const sendButton = document.getElementById("chat-send");
    if (sendButton) {
      sendButton.addEventListener("click", () => this.sendMessage());
    }
  }

  showWelcomeMessage() {
    // Clear existing welcome message from HTML
    const chatBody = document.getElementById("chat-body");
    if (chatBody) {
      chatBody.innerHTML = "";
    }
    
    const welcomeIntent = this.intents['ichaohoi'] || this.intents['Default Welcome Intent'];
    if (welcomeIntent && welcomeIntent.responses && welcomeIntent.responses[0]) {
      const messages = welcomeIntent.responses[0].messages;
      if (messages && messages[0] && messages[0].speech) {
        const welcomeText = messages[0].speech[0];
        this.addBotMessage(welcomeText);
        return;
      }
    }
    
    // Fallback welcome message
    this.addBotMessage("H·∫° Mi√™n xin ch√†o, c·∫£m ∆°n b·∫°n ƒë√£ li√™n h·ªá. H·∫° Mi√™n c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n ·∫°?");
  }

  sendMessage() {
    const chatInput = document.getElementById("chat-input-field");
    if (!chatInput) return;

    const message = chatInput.value.trim();
    if (!message) return;

    // Add user message to chat
    this.addUserMessage(message);

    // Clear input
    chatInput.value = "";

    // Process message
    this.processMessage(message);
  }

  addUserMessage(message) {
    const chatBody = document.getElementById("chat-body");
    if (!chatBody) return;

    const messageDiv = document.createElement("div");
    messageDiv.className = "user-message";
    messageDiv.textContent = message;
    chatBody.appendChild(messageDiv);
    chatBody.scrollTop = chatBody.scrollHeight;
  }

  addBotMessage(message) {
    const chatBody = document.getElementById("chat-body");
    if (!chatBody) return;

    const messageDiv = document.createElement("div");
    messageDiv.className = "bot-message";
    messageDiv.innerHTML = this.formatMessage(message);
    chatBody.appendChild(messageDiv);
    chatBody.scrollTop = chatBody.scrollHeight;
  }

  formatMessage(message) {
    // Convert line breaks to <br>
    return message.replace(/\n/g, '<br>');
  }

  async processMessage(message) {
    console.log('üîç Processing message:', message);
    
    const typingDiv = this.showTypingIndicator();
    
    try {
      // Find matching intent
      const matchedIntent = this.findMatchingIntent(message);
      
      if (matchedIntent) {
        console.log(`‚úÖ Matched intent: ${matchedIntent.name}`);
        console.log(`üìù Message: "${message}"`);
        console.log(`üéØ Intent response:`, matchedIntent.responses?.[0]?.messages?.[0]?.speech?.[0]);
        this.conversationContext.currentIntent = matchedIntent;
        
        // Extract entities from message
        const entities = this.extractEntities(message);
        this.conversationContext.currentEntities = entities;
        
        // Get response from intent
        const response = this.getIntentResponse(matchedIntent, entities);
        this.hideTypingIndicator(typingDiv);
        this.addBotMessage(response);
        
      } else {
        console.log('‚ö†Ô∏è No intent matched, trying smart fallback');
        
        // Try to provide a smart response based on message content
        const smartResponse = this.getSmartFallbackResponse(message);
        this.hideTypingIndicator(typingDiv);
        this.addBotMessage(smartResponse);
      }
      
      // Add to conversation history
      this.conversationContext.conversationHistory.push({
        message: message,
        intent: this.conversationContext.currentIntent?.name,
        entities: this.conversationContext.currentEntities,
        timestamp: new Date()
      });
      
    } catch (error) {
      console.error('‚ùå Error processing message:', error);
      this.hideTypingIndicator(typingDiv);
      this.addBotMessage("Xin l·ªói, c√≥ l·ªói x·∫£y ra. B·∫°n c√≥ th·ªÉ th·ª≠ l·∫°i kh√¥ng?");
    }
  }

  findMatchingIntent(message) {
    const lowerMessage = message.toLowerCase();
    
    // Priority order: specific intents first, then general ones
    const priorityIntents = [
      // Most specific service intents first - TTworkshop has more specific keywords
      'ituvan - dichvu - TTworkshop',
      'ituvan - dichvu - TGworkshop',
      'ituvan - dichvu - decorsukien', 
      'ituvan - dichvu - thietketheoyeucau',
      'ituvan - sanpham - xemmau',
      
      // General service/product intents
      'ituvan - dichvu',
      'ituvan - sanpham',
      
      // Other specific intents
      'idathoa',
      'ithongtinshop',
      'iphiship',
      'iPTTT',
      'idealhot',
      'ihuydon',
      'iketthuc',
      'iphanhoitot',
      'iphanhoixau',
      'ithuthiep',
      'itracuudonhang',
      
      // General intents last
      'ituvan',
      'ichaohoi',
      'Default Welcome Intent',
      'Default Fallback Intent'
    ];
    
    // Check priority intents first
    for (const intentName of priorityIntents) {
      if (this.intents[intentName] && this.checkIntentMatch(intentName, lowerMessage)) {
        console.log(`üéØ Found matching intent: ${intentName} for message: "${lowerMessage}"`);
        return this.intents[intentName];
      }
    }
    
    // Fallback: check remaining intents
    for (const [intentName, intentData] of Object.entries(this.intents)) {
      if (!priorityIntents.includes(intentName) && this.checkIntentMatch(intentName, lowerMessage)) {
        return intentData;
      }
    }
    
    return null;
  }

  checkIntentMatch(intentName, message) {
    // Load training phrases for this intent
    const trainingPhrases = this.getTrainingPhrases(intentName);
    
    if (!trainingPhrases) return false;
    
    console.log(`üîç Checking intent: ${intentName} with phrases:`, trainingPhrases);
    
    // Check if message contains any training phrase
    for (const phrase of trainingPhrases) {
      const lowerPhrase = phrase.toLowerCase();
      
      // Exact match for single words (like "workshop")
      if (lowerPhrase.length <= 10) {
        if (message === lowerPhrase || message.includes(` ${lowerPhrase} `) || 
            message.startsWith(`${lowerPhrase} `) || message.endsWith(` ${lowerPhrase}`)) {
          console.log(`‚úÖ Exact match found: "${phrase}" in "${message}"`);
          return true;
        }
      } else {
        // Partial match for longer phrases
        if (message.includes(lowerPhrase)) {
          console.log(`‚úÖ Partial match found: "${phrase}" in "${message}"`);
          return true;
        }
      }
    }
    
    return false;
  }

  getTrainingPhrases(intentName) {
    try {
      // Load training phrases from usersays file
      const response = fetch(`intents/${intentName}_usersays_vi.json`);
      // Note: This would need to be loaded asynchronously in a real implementation
      // For now, we'll use basic keyword matching
      return this.getBasicKeywords(intentName);
    } catch (error) {
      return this.getBasicKeywords(intentName);
    }
  }

  getBasicKeywords(intentName) {
    const keywordMap = {
      'ichaohoi': ['ch√†o', 'hello', 'hi', 'xin ch√†o', 'h√© l√¥', 'h√≠ lu', 'l√¥', 'alo'],
      'idathoa': ['ƒë·∫∑t', 'mua', 'ch·ªët', 'l·∫•y', 'xu·ªëng ti·ªÅn'],
      'ituvan': ['t∆∞ v·∫•n', 'h·ªèi', 'c·∫ßn t∆∞ v·∫•n', 'mu·ªën t∆∞ v·∫•n'],
      'ituvan - sanpham': ['s·∫£n ph·∫©m', 'hoa', 'sp', 'm·∫∑t h√†ng', 'b√≥ hoa', 'l·∫µng hoa', 'b√¨nh hoa', 'h·ªôp mica'],
      'ituvan - dichvu': ['d·ªãch v·ª•', 'service', 'workshop', 's·ª± ki·ªán', 'thi·∫øt k·∫ø', 'trang tr√≠'],
      'ituvan - dichvu - TGworkshop': ['workshop', 'tham gia', 'h·ªçc', 'l·ªõp h·ªçc'],
      'ituvan - dichvu - TTworkshop': ['workshop', 'b√≥ hoa', 'd·∫°y b√≥ hoa', 'l·ªõp b√≥ hoa', 'h·ªçc b√≥ hoa', '650k', '15 h√†ng th√°ng'],
      'ituvan - dichvu - decorsukien': ['trang tr√≠', 's·ª± ki·ªán', 'event', 'decor'],
      'ituvan - dichvu - thietketheoyeucau': ['thi·∫øt k·∫ø', 'theo y√™u c·∫ßu', 'custom', 'ri√™ng'],
      'ithongtinshop': ['th√¥ng tin', 'shop', 'c·ª≠a h√†ng', 'ƒë·ªãa ch·ªâ', 'hotline'],
      'iphiship': ['giao h√†ng', 'ship', 'delivery', 'ph√≠ ship'],
      'iPTTT': ['thanh to√°n', 'payment', 'ti·ªÅn', 'gi√°'],
      'idealhot': ['deal', 'hot', 'khuy·∫øn m√£i', 'gi·∫£m gi√°'],
      'ihuydon': ['h·ªßy', 'cancel', 'h·ªßy ƒë∆°n'],
      'iketthuc': ['t·∫°m bi·ªát', 'bye', 'goodbye', 'k·∫øt th√∫c'],
      'iphanhoitot': ['c·∫£m ∆°n', 'thank', 't·ªët', 'hay'],
      'iphanhoixau': ['t·ªá', 'x·∫•u', 'kh√¥ng t·ªët', 'bad'],
      'ithuthiep': ['thi·ªáp', 'th∆∞', 'th∆∞ tay'],
      'itracuudonhang': ['tra c·ª©u', 'ƒë∆°n h√†ng', 'order', 't√¨m ƒë∆°n']
    };
    
    return keywordMap[intentName] || [];
  }

  extractEntities(message) {
    const lowerMessage = message.toLowerCase();
    const extractedEntities = {};
    
    // Check each entity
    for (const [entityName, entityData] of Object.entries(this.entities)) {
      if (entityData.entries) {
        for (const entry of entityData.entries) {
          // Check main value
          if (lowerMessage.includes(entry.value.toLowerCase())) {
            extractedEntities[entityName] = entry.value;
            break;
          }
          
          // Check synonyms
          for (const synonym of entry.synonyms) {
            if (lowerMessage.includes(synonym.toLowerCase())) {
              extractedEntities[entityName] = entry.value;
              break;
            }
          }
        }
      }
    }
    
    return extractedEntities;
  }

  getIntentResponse(intent, entities) {
    if (!intent.responses || !intent.responses[0]) {
      return this.getFallbackResponse();
    }
    
    const response = intent.responses[0];
    if (!response.messages || !response.messages[0]) {
      return this.getFallbackResponse();
    }
    
    const messages = response.messages[0].speech;
    if (!messages || messages.length === 0) {
      return this.getFallbackResponse();
    }
    
    // Get random response from available messages
    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
    
    // Enhance response with links based on intent
    return this.enhanceResponseWithLinks(randomMessage, intent, entities);
  }

  enhanceResponseWithLinks(response, intent, entities) {
    let enhancedResponse = response;
    
    // Add links based on intent type
    switch (intent.name) {
      case 'idathoa':
        enhancedResponse += "\n\nüëâ <a href=\"shop.html\" target=\"_blank\">Xem s·∫£n ph·∫©m v√† ƒë·∫∑t h√†ng</a>";
        enhancedResponse += "\nüëâ <a href=\"products.html\" target=\"_blank\">Xem danh s√°ch s·∫£n ph·∫©m chi ti·∫øt</a>";
        break;
        
      case 'ituvan - sanpham':
      case 'ituvan - sanpham - xemmau':
        enhancedResponse += "\n\nüëâ <a href=\"products.html\" target=\"_blank\">Xem danh s√°ch s·∫£n ph·∫©m chi ti·∫øt</a>";
        enhancedResponse += "\nüëâ <a href=\"shop.html\" target=\"_blank\">Xem shop online</a>";
        break;
        
      case 'ituvan - dichvu':
      case 'ituvan - dichvu - decorsukien':
      case 'ituvan - dichvu - TGworkshop':
      case 'ituvan - dichvu - TTworkshop':
      case 'ituvan - dichvu - thietketheoyeucau':
        enhancedResponse += "\n\nüëâ <a href=\"services.html\" target=\"_blank\">Xem d·ªãch v·ª• c·ªßa ch√∫ng t√¥i</a>";
        break;
        
      case 'idealhot':
      case 'idealhotthang10':
        enhancedResponse += "\n\nüëâ <a href=\"shop.html\" target=\"_blank\">Xem deal hot</a>";
        enhancedResponse += "\nüëâ <a href=\"products.html\" target=\"_blank\">Xem t·∫•t c·∫£ s·∫£n ph·∫©m</a>";
        break;
        
      case 'ithongtinshop':
        enhancedResponse += "\n\nüëâ <a href=\"about.html\" target=\"_blank\">Gi·ªõi thi·ªáu v·ªÅ H·∫° Mi√™n</a>";
        enhancedResponse += "\nüëâ <a href=\"contact.html\" target=\"_blank\">Th√¥ng tin li√™n h·ªá</a>";
        break;
        
      case 'iphiship':
      case 'iPTTT':
        enhancedResponse += "\n\nüëâ <a href=\"contact.html\" target=\"_blank\">Th√¥ng tin giao h√†ng</a>";
        break;
        
      default:
        // For general intents, only add links if specifically about products or services
        // Check if the message content or entities indicate product interest
        const hasProductEntity = entities && (
          entities['esanpham'] || 
          entities['eloaihoa'] || 
          entities['emauhoa'] || 
          entities['esoluong']
        );
        
        // Check if the message content or entities indicate service interest  
        const hasServiceEntity = entities && (
          entities['edichvu'] || 
          entities['etuvan']
        );
        
        // Only add product links if specifically about products
        if (hasProductEntity || (enhancedResponse.toLowerCase().includes('s·∫£n ph·∫©m') && !enhancedResponse.toLowerCase().includes('d·ªãch v·ª•'))) {
          enhancedResponse += "\n\nüëâ <a href=\"products.html\" target=\"_blank\">Xem danh s√°ch s·∫£n ph·∫©m</a>";
        }
        
        // Only add service links if specifically about services
        if (hasServiceEntity || (enhancedResponse.toLowerCase().includes('d·ªãch v·ª•') && !enhancedResponse.toLowerCase().includes('s·∫£n ph·∫©m'))) {
          enhancedResponse += "\n\nüëâ <a href=\"services.html\" target=\"_blank\">Xem d·ªãch v·ª•</a>";
        }
        break;
    }
    
    return enhancedResponse;
  }

  getSmartFallbackResponse(message) {
    const lowerMessage = message.toLowerCase();
    
    // Check for specific keywords and provide targeted responses
    if (lowerMessage.includes('b√≥ hoa') || lowerMessage.includes('d·∫°y b√≥ hoa') || lowerMessage.includes('l·ªõp b√≥ hoa') || lowerMessage.includes('h·ªçc b√≥ hoa') || lowerMessage.includes('650k') || lowerMessage.includes('15 h√†ng th√°ng')) {
      return "D·∫°, Hi·ªán t·∫°i b√™n ti·ªám c√≥ t·ªï ch·ª©c Workshop d·∫°y b√≥ hoa v√†o ng√†y 15 h√†ng th√°ng v·ªõi chi ph√≠ 650k/ng∆∞·ªùi (ƒë√£ bao g·ªìm: tr√†, b√°nh,...)\nƒê·∫øn v·ªõi Workshop, b·∫°n kh√¥ng ch·ªâ bi·∫øt c√°ch t·ª± tay b√≥ m·ªôt b√¥ng hoa m√† c√≤n ƒë∆∞·ª£c tr·∫£i nghi·ªám:\n- Kh√¥ng kh√≠ th∆∞ gi√£n, ch·ªØa l√†nh\n- ƒê∆∞·ª£c h·ªçc v√† h∆∞·ªõng d·∫´n tr·ª±c ti·∫øp b·ªüi c√°c florist chuy√™n nghi·ªáp\n- K·∫øt n·ªëi v·ªõi ng∆∞·ªùi c√πng ƒëam m√™ \n- V·ª´a c√≥ hoa xinh, ·∫£nh ƒë·∫πp mang v·ªÅ; v·ª´a h·ªçc th√™m ƒë∆∞·ª£c c√°c ki·∫øn th·ª©c v·ªÅ hoa\nB·∫°n c√≥ mu·ªën H·∫° Mi√™n gi√∫p b·∫°n gi·ªØ m·ªôt ch·ªó trong th√°ng n√†y kh√¥ng ·∫°?";
    }
    
    if (lowerMessage.includes('workshop') || lowerMessage.includes('l·ªõp h·ªçc')) {
      return "C·∫£m ∆°n kh√°ch y√™u ƒë√£ quan t√¢m ƒë·∫øn d·ªãch v·ª• workshop b√™n ti·ªám, H·∫° Mi√™n r·∫•t vui khi c√≥ s·ª± hi·ªán di·ªán c·ªßa b·∫°n.\nB·∫°n vui l√≤ng ƒë·∫∑t c·ªçc 50% ti·ªÅn v√© l√† 352k qua \n- stk: 12422555 ng√¢n h√†ng: MT Bank\n- N·ªôi dung ck: T√™n ng∆∞·ªùi tham gia   ng√†y tham gia";
    }
    
    if (lowerMessage.includes('trang tr√≠') || lowerMessage.includes('s·ª± ki·ªán') || lowerMessage.includes('event')) {
      return "B·∫°n vui l√≤ng li√™n h·ªá t·ªõi s·ªë hotline: 0398068898 ƒë·ªÉ ƒë∆∞·ª£c ti·ªám h·ªó tr·ª£ s·ªõm nh·∫•t v√† ƒë·ªìng h√†nh trong qu√° tr√¨nh s·ª≠ d·ª•ng d·ªãch v·ª• ·∫°.";
    }
    
    if (lowerMessage.includes('thi·∫øt k·∫ø') || lowerMessage.includes('theo y√™u c·∫ßu')) {
      return "B·∫°n vui l√≤ng li√™n h·ªá t·ªõi s·ªë hotline: 0398068898 ƒë·ªÉ ƒë∆∞·ª£c ti·ªám h·ªó tr·ª£ s·ªõm nh·∫•t v√† ƒë·ªìng h√†nh trong qu√° tr√¨nh s·ª≠ d·ª•ng d·ªãch v·ª• ·∫°.";
    }
    
    if (lowerMessage.includes('s·∫£n ph·∫©m') || lowerMessage.includes('hoa')) {
      return "Hi·ªán t·∫°i H·∫° Mi√™n c√≥ c√°c s·∫£n ph·∫©m: l·∫µng hoa, hoa b√≥, b√¨nh hoa, h·ªôp mica hoa ·∫°.";
    }
    
    if (lowerMessage.includes('d·ªãch v·ª•')) {
      return "H·∫° Mi√™n ƒëang c√≥ c√°c d·ªãch v·ª• nh∆∞: thi·∫øt k·∫ø hoa theo y√™u c·∫ßu, workshop v√† li√™n k·∫øt t·ªï ch·ª©c s·ª± ki·ªán. B·∫°n mu·ªën ti·ªám m√¨nh t∆∞ v·∫•n d·ªãch v·ª• n√†o ·∫°?";
    }
    
    // Default fallback
    return this.getFallbackResponse();
  }

  getFallbackResponse() {
    const fallbackIntent = this.intents['Default Fallback Intent'];
    if (fallbackIntent && fallbackIntent.responses && fallbackIntent.responses[0]) {
      const messages = fallbackIntent.responses[0].messages;
      if (messages && messages[0] && messages[0].speech) {
        return messages[0].speech[0];
      }
    }
    
    return "H·∫° Mi√™n xin ph√©p ƒë∆∞·ª£c hi·ªÉu √Ω b·∫°n nh∆∞ sau, b·∫°n ƒëang c·∫ßn t∆∞ v·∫•n ƒë·∫∑t hoa ph·∫£i kh√¥ng ·∫°?";
  }

  showTypingIndicator() {
    const chatBody = document.getElementById("chat-body");
    if (!chatBody) return null;

    const typingDiv = document.createElement("div");
    typingDiv.className = "typing-indicator";
    typingDiv.innerHTML = `
      <div class="typing-dots">
        <span></span>
        <span></span>
        <span></span>
      </div>
    `;
    chatBody.appendChild(typingDiv);
    chatBody.scrollTop = chatBody.scrollHeight;
    
    return typingDiv;
  }

  hideTypingIndicator(typingDiv) {
    if (typingDiv && typingDiv.parentNode) {
      typingDiv.parentNode.removeChild(typingDiv);
    }
  }

  toggleChat() {
    const chatBox = document.getElementById("chatbot-box");
    if (!chatBox) return;

    if (chatBox.classList.contains("hidden")) {
      chatBox.classList.remove("hidden");
    } else {
      chatBox.classList.add("hidden");
    }
  }

  // Public API methods
  getLoadedIntents() {
    return Object.keys(this.intents);
  }

  getLoadedEntities() {
    return Object.keys(this.entities);
  }

  getConversationHistory() {
    return this.conversationContext.conversationHistory;
  }

  resetConversation() {
    this.conversationContext = {
      currentIntent: null,
      currentEntities: {},
      conversationHistory: []
    };
    console.log('üîÑ Conversation reset');
  }

  // Debug function to test intent matching
  testIntentMatching(message) {
    console.log(`üß™ Testing intent matching for: "${message}"`);
    const matchedIntent = this.findMatchingIntent(message);
    if (matchedIntent) {
      console.log(`‚úÖ Matched intent: ${matchedIntent.name}`);
      console.log(`üìù Response:`, matchedIntent.responses?.[0]?.messages?.[0]?.speech?.[0]);
    } else {
      console.log(`‚ùå No intent matched`);
    }
    return matchedIntent;
  }
}

// Initialize chatbot when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  window.haMienChatbot = new HaMienChatbot();
});

// Export for potential external use
if (typeof module !== 'undefined' && module.exports) {
  module.exports = HaMienChatbot;
}