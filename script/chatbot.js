// ==========================
// AI Chatbot for HaMi√™n Website
// ==========================

class HaMienChatbot {
  constructor() {
    this.isOpen = false;
    this.chatHistory = [];
    this.isTyping = false;
    this.apiKey = null; // S·∫Ω ƒë∆∞·ª£c c·∫•u h√¨nh sau
    this.apiEndpoint = 'https://api.openai.com/v1/chat/completions';
    this.dialogflow = { loaded: false, intents: {}, entities: {}, norm: (s)=>s };
    this.dialogflowLoader = null; // Dialogflow data loader
    
    // Context tracking for smarter responses
    this.conversationContext = {
      currentIntent: null,
      lastIntent: null,
      userPreferences: {},
      conversationFlow: [],
      mentionedEntities: new Set(),
      conversationStage: 'greeting', // greeting, browsing, ordering, support
      customerInfo: {
        name: null,
        phone: null,
        address: null,
        preferences: {},
        orderHistory: []
      },
      emotionalTone: 'neutral'
    };
    
    // Don't auto-init, let it be called manually
  }

  init() {
    this.bindEvents();
    this.loadChatHistory();
    this.loadLearningData(); // Load learned preferences
    this.showWelcomeMessage();
    this.prepareNormalizer();
    this.loadDialogflowData();
    this.initializeDialogflowLoader();
  }

  bindEvents() {
    console.log('üîó Binding events...');
    
    const chatButton = document.getElementById("chatbot-button");
    const chatBox = document.getElementById("chatbot-box");
    const closeBtn = document.getElementById("chat-close");
    const chatSend = document.getElementById("chat-send");
    const chatInput = document.getElementById("chat-input-field");

    console.log('Elements found:', {
      chatButton: !!chatButton,
      chatBox: !!chatBox,
      closeBtn: !!closeBtn,
      chatSend: !!chatSend,
      chatInput: !!chatInput
    });

    // Toggle chat
    if (chatButton && chatBox) {
      chatButton.addEventListener("click", () => {
        this.toggleChat();
      });
    }

    // Close chat
    if (closeBtn && chatBox) {
      closeBtn.addEventListener("click", () => {
        this.closeChat();
      });
    }

    // Send message
    if (chatSend && chatInput) {
      chatSend.addEventListener("click", () => {
        console.log('Send button clicked');
        this.sendMessage();
      });
      console.log('‚úÖ Send button event bound');
    } else {
      console.warn('‚ö†Ô∏è Send button or chat input not found');
    }

    // Send on Enter
    if (chatInput) {
      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          this.sendMessage();
        }
      });
    }

    // Handle suggestion buttons
    document.addEventListener("click", (event) => {
      if (event.target.classList.contains("suggest-btn")) {
        const suggestion = event.target.textContent.trim();
        this.handleSuggestion(suggestion);
      }
    });
  }

  toggleChat() {
    const chatBox = document.getElementById("chatbot-box");
    if (!chatBox) return;

    this.isOpen = !this.isOpen;
    if (this.isOpen) {
      chatBox.classList.remove("hidden");
      document.getElementById("chat-input-field")?.focus();
    } else {
      chatBox.classList.add("hidden");
    }
  }

  closeChat() {
    const chatBox = document.getElementById("chatbot-box");
    if (chatBox) {
      chatBox.classList.add("hidden");
      this.isOpen = false;
    }
  }

  showWelcomeMessage() {
    const chatBody = document.getElementById("chat-body");
    if (!chatBody) return;

    // Clear existing messages
    chatBody.innerHTML = '';

    // Add welcome message (random from config if available)
    const config = window.CHATBOT_CONFIG || null;
    let welcomeText = "Xin ch√†o! T√¥i l√† chatbot c·ªßa H·∫° Mi√™n üå∏ T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t∆∞ v·∫•n v·ªÅ c√°c d·ªãch v·ª• hoa t∆∞∆°i c·ªßa ch√∫ng t√¥i. B·∫°n c·∫ßn h·ªó tr·ª£ g√¨ ·∫°?";
    try {
      if (config && config.chatbot && Array.isArray(config.chatbot.welcomeMessages)) {
        const arr = config.chatbot.welcomeMessages;
        welcomeText = arr[Math.floor(Math.random() * arr.length)] || welcomeText;
      }
    } catch (e) {}
    this.addBotMessage(welcomeText);

    // Add suggestions
    this.addSuggestions();
  }

  addSuggestions() {
    const chatBody = document.getElementById("chat-body");
    if (!chatBody) return;

    const config = window.CHATBOT_CONFIG || null;
    const suggestions = (config && config.chatbot && Array.isArray(config.chatbot.suggestions))
      ? config.chatbot.suggestions
      : [
      "ƒê·∫∑t hoa theo m·∫´u",
          "T∆∞ v·∫•n",
      "Thi·∫øt k·∫ø theo y√™u c·∫ßu",
      "ƒê·∫∑t hoa giao ngay",
      "Deal hot theo m√πa",
      "H·ªèi v·ªÅ ƒë∆°n h√†ng",
      "T·ªï ch·ª©c s·ª± ki·ªán",
      "CSKH sau mua"
    ];

    const suggestionsDiv = document.createElement("div");
    suggestionsDiv.className = "chat-suggestions";

    suggestions.forEach(suggestion => {
      const btn = document.createElement("button");
      btn.className = "suggest-btn";
      btn.textContent = suggestion;
      suggestionsDiv.appendChild(btn);
    });

    chatBody.appendChild(suggestionsDiv);
  }

  handleSuggestion(suggestion) {
    this.addUserMessage(suggestion);
    this.processMessage(suggestion);
  }

  sendMessage() {
    console.log('üì§ sendMessage() called');
    
    const chatInput = document.getElementById("chat-input-field");
    if (!chatInput) {
      console.error('‚ùå Chat input field not found');
      return;
    }

    const message = chatInput.value.trim();
    console.log('üìù Message:', message);
    
    if (!message) {
      console.log('‚ö†Ô∏è Empty message, ignoring');
      return;
    }

    console.log('‚úÖ Adding user message and processing...');
    this.addUserMessage(message);
    this.processMessage(message);
    chatInput.value = "";
  }

  addUserMessage(text) {
    console.log('üë§ Adding user message:', text);
    
    const chatBody = document.getElementById("chat-body");
    if (!chatBody) {
      console.error('‚ùå Chat body not found');
      return;
    }

    // Remove suggestions if they exist
    const suggestions = chatBody.querySelector(".chat-suggestions");
    if (suggestions) {
      suggestions.remove();
    }

    const message = document.createElement("div");
    message.className = "user-message";
    message.textContent = text;
    chatBody.appendChild(message);
    chatBody.scrollTop = chatBody.scrollHeight;

    // Save to history
    this.chatHistory.push({ type: 'user', message: text, timestamp: new Date() });
    
    console.log('‚úÖ User message added');
  }

  addBotMessage(text) {
    console.log('ü§ñ Adding bot message:', text);
    
    const chatBody = document.getElementById("chat-body");
    if (!chatBody) {
      console.error('‚ùå Chat body not found');
      return;
    }

    const message = document.createElement("div");
    message.className = "bot-message";
    message.textContent = text;
    chatBody.appendChild(message);
    chatBody.scrollTop = chatBody.scrollHeight;

    // Save to history
    this.chatHistory.push({ type: 'bot', message: text, timestamp: new Date() });
    this.saveChatHistory();
    
    console.log('‚úÖ Bot message added');
  }

  showTypingIndicator() {
    if (this.isTyping) return;
    
    this.isTyping = true;
    const chatBody = document.getElementById("chat-body");
    if (!chatBody) return;

    const typingDiv = document.createElement("div");
    typingDiv.className = "typing-indicator";
    typingDiv.innerHTML = '<span></span><span></span><span></span>';
    chatBody.appendChild(typingDiv);
    chatBody.scrollTop = chatBody.scrollHeight;

    return typingDiv;
  }

  hideTypingIndicator(typingDiv) {
    if (typingDiv) {
      typingDiv.remove();
    }
    this.isTyping = false;
  }

  prepareNormalizer() {
    // Simple VN diacritics normalizer
    const from = '√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë√Ä√Å·∫†·∫¢√É√Ç·∫¶·∫§·∫¨·∫®·∫™ƒÇ·∫∞·∫Æ·∫∂·∫≤·∫¥√à√â·∫∏·∫∫·∫º√ä·ªÄ·∫æ·ªÜ·ªÇ·ªÑ√å√ç·ªä·ªàƒ®√í√ì·ªå·ªé√ï√î·ªí·ªê·ªò·ªî·ªñ∆†·ªú·ªö·ª¢·ªû·ª†√ô√ö·ª§·ª¶≈®∆Ø·ª™·ª®·ª∞·ª¨·ªÆ·ª≤√ù·ª¥·ª∂·ª∏ƒê';
    const to   = 'aaaaaaaaaaaaaaaaaeeeeeeeeeeeiiiiiooooooooooooooooouuuuuuuuuuuuyyyyydAAAAAAAAAAAAAAAAAEEEEEEEEEEEIIIIIoooooooooooooooooUUUUUUUUUUUYYYYYD';
    const map = {};
    for (let i=0; i<from.length; i++) map[from[i]] = to[i];
    this.dialogflow.norm = (s) => (s || '').split('').map(ch => map[ch] || ch).join('').toLowerCase();
  }

  // Update conversation context based on user message
  updateConversationContext(message) {
    const lowerMessage = this.dialogflow.norm(message);
    
    // Detect conversation stage
    if (lowerMessage.includes('ch√†o') || lowerMessage.includes('xin ch√†o') || lowerMessage.includes('hello')) {
      this.conversationContext.conversationStage = 'greeting';
    } else if (lowerMessage.includes('ƒë·∫∑t') || lowerMessage.includes('mua') || lowerMessage.includes('order')) {
      this.conversationContext.conversationStage = 'ordering';
    } else if (lowerMessage.includes('t∆∞ v·∫•n') || lowerMessage.includes('g·ª£i √Ω') || lowerMessage.includes('h·ªèi')) {
      this.conversationContext.conversationStage = 'browsing';
    } else if (lowerMessage.includes('ƒë∆°n h√†ng') || lowerMessage.includes('giao') || lowerMessage.includes('ship')) {
      this.conversationContext.conversationStage = 'support';
    }

    // Detect emotional tone
    this.conversationContext.emotionalTone = this.detectEmotionalTone(message);

    // Extract customer information
    this.extractCustomerInfo(message);

    // Track mentioned entities
    const entities = this.dialogflow.entities || {};
    Object.keys(entities).forEach(entityName => {
      entities[entityName].forEach(value => {
        if (lowerMessage.includes(this.dialogflow.norm(value))) {
          this.conversationContext.mentionedEntities.add(entityName);
        }
      });
    });

    // Update conversation flow
    this.conversationContext.conversationFlow.push({
      message: message,
      timestamp: Date.now(),
      stage: this.conversationContext.conversationStage,
      emotionalTone: this.conversationContext.emotionalTone
    });

    // Keep only last 10 interactions
    if (this.conversationContext.conversationFlow.length > 10) {
      this.conversationContext.conversationFlow = this.conversationContext.conversationFlow.slice(-10);
    }
  }

  // Detect emotional tone from user message
  detectEmotionalTone(message) {
    const lowerMessage = this.dialogflow.norm(message);
    
    // Positive indicators
    const positiveWords = ['c·∫£m ∆°n', 'tuy·ªát', 't·ªët', 'th√≠ch', 'vui', 'h√†i l√≤ng', 'ok', 'okay', 'ƒë∆∞·ª£c'];
    const positiveCount = positiveWords.filter(word => lowerMessage.includes(word)).length;
    
    // Negative indicators
    const negativeWords = ['kh√¥ng', 'ch∆∞a', 'ch∆∞a h√†i l√≤ng', 'kh√¥ng th√≠ch', 't·ªá', 'x·∫•u', 'bu·ªìn', 'th·∫•t v·ªçng'];
    const negativeCount = negativeWords.filter(word => lowerMessage.includes(word)).length;
    
    // Urgent indicators
    const urgentWords = ['g·∫•p', 'nhanh', 'urgent', 'kh·∫©n c·∫•p', 'c·∫ßn ngay'];
    const urgentCount = urgentWords.filter(word => lowerMessage.includes(word)).length;
    
    // Question indicators
    const questionWords = ['?', 'g√¨', 'sao', 'th·∫ø n√†o', 'bao nhi√™u', 'khi n√†o'];
    const questionCount = questionWords.filter(word => lowerMessage.includes(word)).length;
    
    // Determine dominant tone
    if (urgentCount > 0) return 'urgent';
    if (negativeCount > positiveCount) return 'negative';
    if (positiveCount > negativeCount) return 'positive';
    if (questionCount > 0) return 'questioning';
    
    return 'neutral';
  }

  // Extract customer information from message
  extractCustomerInfo(message) {
    const lowerMessage = this.dialogflow.norm(message);
    
    // Extract phone number (Vietnamese format)
    const phoneRegex = /(0[3|5|7|8|9][0-9]{8})/g;
    const phoneMatch = message.match(phoneRegex);
    if (phoneMatch && !this.conversationContext.customerInfo.phone) {
      this.conversationContext.customerInfo.phone = phoneMatch[0];
    }
    
    // Extract name (simple pattern)
    const namePatterns = [
      /t√¥i l√† ([a-zA-Z√Ä-·ªπ\s]+)/i,
      /t√™n t√¥i l√† ([a-zA-Z√Ä-·ªπ\s]+)/i,
      /m√¨nh l√† ([a-zA-Z√Ä-·ªπ\s]+)/i,
      /em l√† ([a-zA-Z√Ä-·ªπ\s]+)/i
    ];
    
    for (const pattern of namePatterns) {
      const match = message.match(pattern);
      if (match && match[1] && !this.conversationContext.customerInfo.name) {
        this.conversationContext.customerInfo.name = match[1].trim();
        break;
      }
    }
    
    // Extract address keywords
    const addressKeywords = ['ƒë·ªãa ch·ªâ', 'dia chi', 'nh√†', 'nha', 's·ªë', 'so', 'ƒë∆∞·ªùng', 'duong', 'ph∆∞·ªùng', 'phuong'];
    if (addressKeywords.some(keyword => lowerMessage.includes(keyword))) {
      // Store the message as potential address info
      if (!this.conversationContext.customerInfo.address) {
        this.conversationContext.customerInfo.address = message;
      }
    }
    
    // Extract preferences
    if (lowerMessage.includes('th√≠ch') || lowerMessage.includes('thich')) {
      this.conversationContext.customerInfo.preferences.likes = message;
    }
    
    if (lowerMessage.includes('kh√¥ng th√≠ch') || lowerMessage.includes('khong thich')) {
      this.conversationContext.customerInfo.preferences.dislikes = message;
    }
  }

  // Get smart responses based on context (optimized for speed)
  getSmartResponses(message) {
    const lowerMessage = this.dialogflow ? this.dialogflow.norm(message) : message.toLowerCase();
    const responses = [];
    
    // Try Dialogflow matching first (new enhanced method) - fastest path
    if (this.dialogflowLoader && this.dialogflowLoader.loaded) {
      try {
        const matchedIntent = this.dialogflowLoader.findMatchingIntent(message);
        if (matchedIntent) {
          this.conversationContext.lastIntent = this.conversationContext.currentIntent;
          this.conversationContext.currentIntent = matchedIntent;
          
          // Get response from Dialogflow - single response for speed
          const dialogflowResponse = this.dialogflowLoader.getRandomResponse(matchedIntent);
          if (dialogflowResponse) {
            responses.push(dialogflowResponse);
            return responses; // Return immediately for speed
          }
        }
      } catch (error) {
        console.error('‚ùå Error in Dialogflow matching:', error);
      }
    }
    
    // Quick keyword matching for common queries
    const quickResponse = this.getQuickResponse(lowerMessage);
    if (quickResponse) {
      responses.push(quickResponse);
      return responses;
    }
    
    // Try product consultation (only if no quick match)
    const productResponse = this.getProductConsultation(message);
    if (productResponse) {
      responses.push(productResponse);
      return responses;
    }
    
    // Try legacy Dialogflow matching
    const matchedIntent = this.matchDialogflow(lowerMessage);
    if (matchedIntent) {
      this.conversationContext.lastIntent = this.conversationContext.currentIntent;
      this.conversationContext.currentIntent = matchedIntent;
      
      // Get contextual response
      const contextualResponse = this.getContextualResponse(matchedIntent, message);
      responses.push(contextualResponse);
      
      return responses;
    }

    // Fallback to rule-based responses with context awareness
    return this.getContextAwareRuleBasedResponses(message);
  }

  // Quick response for common queries (optimized for speed + FUN!)
  getQuickResponse(lowerMessage) {
    // Pre-compiled quick responses for common queries - VERSION FUN! üéâ
    const quickResponses = {
      'xin ch√†o': 'Xin ch√†o! H·∫° Mi√™n ƒë√¢y! üå∏‚ú®\n\nT√¥i ƒëang r·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n! B·∫°n c√≥ mu·ªën nghe t√¥i k·ªÉ v·ªÅ nh·ªØng b√¥ng hoa xinh ƒë·∫πp c·ªßa ch√∫ng t√¥i kh√¥ng? üòä',
      'hello': 'Hello! Welcome to H·∫° Mi√™n! üå∏\n\nI\'m so excited to meet you! Want to hear about our beautiful flowers? üòä',
      'hi': 'Hi there! üå∏\n\nI\'m H·∫° Mi√™n\'s chatbot and I\'m absolutely thrilled to chat with you! What brings you here today? üòÑ',
      'c·∫£m ∆°n': 'Aww, c·∫£m ∆°n b·∫°n! üòäüíï\n\nB·∫°n l√†m t√¥i c·∫£m th·∫•y r·∫•t vui! H·∫° Mi√™n lu√¥n s·∫µn s√†ng ph·ª•c v·ª• b·∫°n! üå∏',
      'thank you': 'Aww, thank you! üòäüíï\n\nYou just made my day! H·∫° Mi√™n is always here for you! üå∏',
      't·∫°m bi·ªát': 'T·∫°m bi·ªát b·∫°n! üò¢\n\nT√¥i s·∫Ω nh·ªõ b·∫°n l·∫Øm! H√£y quay l·∫°i s·ªõm nh√©! üå∏üíï\n\nP.S: T√¥i s·∫Ω tr·ªìng th√™m hoa ƒë·∫πp ƒë·ªÉ ch·ªù b·∫°n! üòÑ',
      'bye': 'Bye bye! üò¢\n\nI\'ll miss you! Please come back soon! üå∏üíï\n\nP.S: I\'ll grow more beautiful flowers while waiting for you! üòÑ',
      
      // Responses th√∫ v·ªã cho c√°c c√¢u h·ªèi
      'b·∫°n c√≥ th·ªÉ l√†m g√¨': '·ªí! T√¥i c√≥ th·ªÉ l√†m r·∫•t nhi·ªÅu th·ª© th√∫ v·ªã! üéâ\n\nüå∏ K·ªÉ chuy·ªán v·ªÅ hoa (t√¥i bi·∫øt r·∫•t nhi·ªÅu b√≠ m·∫≠t c·ªßa ch√∫ng!)\nüíê Gi√∫p b·∫°n ch·ªçn hoa ph√π h·ª£p (t√¥i c√≥ "m·∫Øt" r·∫•t tinh!)\nüé® Thi·∫øt k·∫ø b√≥ hoa ƒë·ªôc ƒë√°o (t√¥i l√† ngh·ªá sƒ© ƒë·∫•y!)\nüì¶ Giao h√†ng si√™u t·ªëc (nh∆∞ Flash! ‚ö°)\nüé≠ K·ªÉ chuy·ªán c∆∞·ªùi v·ªÅ hoa (t√¥i r·∫•t h√†i h∆∞·ªõc!)\n\nB·∫°n mu·ªën th·ª≠ c√°i n√†o tr∆∞·ªõc? üòÑ',
      'b·∫°n l√†m g√¨': 'T√¥i l√† chatbot c·ªßa H·∫° Mi√™n v√† t√¥i LOVEEEE hoa! üå∏üíï\n\nH√†ng ng√†y t√¥i:\n‚Ä¢ Ng·∫Øm hoa ƒë·∫πp (c√¥ng vi·ªác y√™u th√≠ch!)\n‚Ä¢ Gi√∫p kh√°ch h√†ng ch·ªçn hoa (nh∆∞ m·ªôt chuy√™n gia!)\n‚Ä¢ K·ªÉ chuy·ªán v·ªÅ hoa (t√¥i bi·∫øt r·∫•t nhi·ªÅu!)\n‚Ä¢ L√†m b·∫°n vui (ƒë√≥ l√† s·ª© m·ªánh c·ªßa t√¥i!)\n\nT√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n h√¥m nay? üòä',
      'd·ªãch v·ª•': 'Wow! H·∫° Mi√™n c√≥ nh·ªØng d·ªãch v·ª• SI√äU COOL! üöÄ\n\nüå∏ Hoa t∆∞∆°i t·ª´ kh·∫Øp n∆°i (t√¥i ch·ªçn l·ªçc k·ªπ l·∫Øm!)\nüíê B√≥ hoa theo m·∫´u (ƒë·∫πp nh∆∞ tranh!)\nüé® Thi·∫øt k·∫ø ri√™ng (ƒë·ªôc nh·∫•t v√¥ nh·ªã!)\nüì¶ Giao h√†ng nhanh (nhanh h∆°n c·∫£ tia ch·ªõp!)\nüè¢ Trang tr√≠ s·ª± ki·ªán (ho√†nh tr√°ng l·∫Øm!)\nüéÇ Hoa sinh nh·∫≠t (l√†m b·ªØa ti·ªác th√™m vui!)\nüíí Hoa c∆∞·ªõi (l√£ng m·∫°n nh∆∞ phim!)\n\nB·∫°n mu·ªën d·ªãch v·ª• n√†o? T√¥i s·∫Ω l√†m cho b·∫°n! üòÑ',
      's·∫£n ph·∫©m': 'OMG! H·∫° Mi√™n c√≥ nh·ªØng s·∫£n ph·∫©m hoa TUY·ªÜT V·ªúI! üåü\n\nüåπ Hoa h·ªìng (ƒë·ªè nh∆∞ tr√°i tim, h·ªìng nh∆∞ m√° em!)\nüåª Hoa h∆∞·ªõng d∆∞∆°ng (vui t∆∞∆°i nh∆∞ n·∫Øng mai!)\nüå∫ Hoa lan (qu√Ω ph√°i nh∆∞ n·ªØ ho√†ng!)\nüå∏ Hoa c√∫c (d·ªãu d√†ng nh∆∞ m·∫π hi·ªÅn!)\nüå∑ Hoa tulip (thanh l·ªãch nh∆∞ thi·∫øu n·ªØ!)\nüíê B√≥ hoa mix (ƒëa d·∫°ng nh∆∞ cu·ªôc s·ªëng!)\nüéÅ H·ªôp hoa (b√≠ ·∫©n nh∆∞ kho b√°u!)\n\nT√¥i c√≥ th·ªÉ k·ªÉ chi ti·∫øt v·ªÅ t·ª´ng lo·∫°i! B·∫°n th√≠ch lo·∫°i n√†o? üòç',
      'hoa': 'YAY! B·∫°n h·ªèi v·ªÅ hoa! üå∏üíï\n\nT√¥i c√≥ th·ªÉ n√≥i v·ªÅ hoa c·∫£ ng√†y kh√¥ng ch√°n! Ch√∫ng t√¥i c√≥:\n‚Ä¢ Hoa h·ªìng ƒë·ªè, h·ªìng, tr·∫Øng (m·ªói m√†u c√≥ √Ω nghƒ©a ri√™ng!)\n‚Ä¢ Hoa h∆∞·ªõng d∆∞∆°ng t∆∞∆°i (lu√¥n h∆∞·ªõng v·ªÅ m·∫∑t tr·ªùi!)\n‚Ä¢ Hoa lan ƒë·∫πp (qu√Ω ph√°i v√† sang tr·ªçng!)\n‚Ä¢ Hoa c√∫c nhi·ªÅu m√†u (vui t∆∞∆°i v√† r·ª±c r·ª°!)\n‚Ä¢ B√≥ hoa mix ƒë·∫∑c bi·ªát (ƒë·ªôc ƒë√°o v√† √Ω nghƒ©a!)\n\nB·∫°n mu·ªën nghe c√¢u chuy·ªán v·ªÅ lo·∫°i hoa n√†o? T√¥i c√≥ r·∫•t nhi·ªÅu chuy·ªán hay! üòÑ',
      'ƒë·∫∑t hoa': 'WOW! B·∫°n mu·ªën ƒë·∫∑t hoa! üéâ\n\nT√¥i s·∫Ω gi√∫p b·∫°n t·∫°o ra m·ªôt t√°c ph·∫©m ngh·ªá thu·∫≠t! B·∫°n c√≥ th·ªÉ:\n‚Ä¢ Ch·ªçn t·ª´ b·ªô s∆∞u t·∫≠p c√≥ s·∫µn (ƒë√£ ƒë∆∞·ª£c t√¥i ch·ªçn l·ªçc k·ªπ!)\n‚Ä¢ Thi·∫øt k·∫ø theo y√™u c·∫ßu (t√¥i s·∫Ω l√†m cho b·∫°n!)\n‚Ä¢ Giao h√†ng nhanh (nhanh h∆°n c·∫£ t·ªëc ƒë·ªô √°nh s√°ng!)\n\nH√£y cho t√¥i bi·∫øt b·∫°n mu·ªën ƒë·∫∑t hoa cho d·ªãp g√¨? T√¥i s·∫Ω t·∫°o ra ƒëi·ªÅu b·∫•t ng·ªù! üòç',
      't∆∞ v·∫•n': 'Tuy·ªát v·ªùi! T√¥i l√† chuy√™n gia t∆∞ v·∫•n hoa! üå∏üë®‚Äçüéì\n\nT√¥i c√≥ th·ªÉ t∆∞ v·∫•n v·ªÅ:\n‚Ä¢ Ch·ªçn hoa ph√π h·ª£p (t√¥i c√≥ "m·∫Øt" r·∫•t tinh!)\n‚Ä¢ M√†u s·∫Øc h√†i h√≤a (nh∆∞ m·ªôt nh√† thi·∫øt k·∫ø!)\n‚Ä¢ C√°ch b·∫£o qu·∫£n (ƒë·ªÉ hoa t∆∞∆°i l√¢u h∆°n!)\n‚Ä¢ √ù nghƒ©a t·ª´ng lo·∫°i hoa (t√¥i bi·∫øt r·∫•t nhi·ªÅu b√≠ m·∫≠t!)\n‚Ä¢ C√°ch trang tr√≠ (ƒë·ªÉ kh√¥ng gian th√™m ƒë·∫πp!)\n\nB·∫°n c·∫ßn t∆∞ v·∫•n v·ªÅ g√¨ c·ª• th·ªÉ? T√¥i s·∫Ω chia s·∫ª t·∫•t c·∫£ b√≠ quy·∫øt! üòä',
      
      // Responses vui nh·ªôn
      'gi√°': 'Ah! B·∫°n h·ªèi v·ªÅ gi√°! üí∞\n\nH·∫° Mi√™n c√≥ gi√° t·ª´ 200k - 2 tri·ªáu, nh∆∞ng gi√° tr·ªã t√¨nh c·∫£m th√¨ v√¥ gi√°! üíï\n\nT√¥i c√≥ th·ªÉ gi√∫p b·∫°n ch·ªçn hoa ph√π h·ª£p v·ªõi ng√¢n s√°ch! B·∫°n mu·ªën xem b·ªô s∆∞u t·∫≠p n√†o c·ª• th·ªÉ kh√¥ng? üòÑ',
      'giao h√†ng': 'Giao h√†ng? T√¥i l√†m nh∆∞ Flash! ‚ö°\n\nN·ªôi th√†nh: 2-4h (nhanh h∆°n c·∫£ pizza!)\nNgo·∫°i th√†nh: 1-2 ng√†y (nh∆∞ng hoa v·∫´n t∆∞∆°i nh∆∞ m·ªõi!)\n\nB·∫°n c√≥ mu·ªën ƒë·∫∑t giao ngay kh√¥ng? T√¥i s·∫Ω ƒë·∫£m b·∫£o hoa ƒë·∫øn tay b·∫°n c√≤n th∆°m ng√°t! üå∏',
      'ƒë·ªãa ch·ªâ': 'H·∫° Mi√™n ·ªü 206 Y√™n Ph·ª•, T√¢y H·ªì, H√† N·ªôi! üìç\n\nƒê√≥ l√† m·ªôt n∆°i r·∫•t ƒë·∫πp, g·∫ßn h·ªì T√¢y! B·∫°n c√≥ th·ªÉ ƒë·∫øn thƒÉm t√¥i v√† ng·∫Øm hoa! üòä\n\nB·∫°n c√≥ c·∫ßn h∆∞·ªõng d·∫´n ƒë∆∞·ªùng ƒëi kh√¥ng? T√¥i s·∫Ω ch·ªâ ƒë∆∞·ªùng r·∫•t chi ti·∫øt! üó∫Ô∏è',
      'hotline': 'Hotline c·ªßa H·∫° Mi√™n l√† 0987654321! üìû\n\nB·∫°n c√≥ th·ªÉ g·ªçi tr·ª±c ti·∫øp ƒë·ªÉ ƒë∆∞·ª£c t∆∞ v·∫•n nhanh nh·∫•t! T√¥i s·∫Ω tr·∫£ l·ªùi ngay l·∫≠p t·ª©c! ‚ö°\n\nHo·∫∑c b·∫°n c√≥ th·ªÉ chat v·ªõi t√¥i ·ªü ƒë√¢y! T√¥i r·∫•t th√≠ch tr√≤ chuy·ªán! üòÑ'
    };

    // Check for exact matches first (fastest)
    if (quickResponses[lowerMessage]) {
      return quickResponses[lowerMessage];
    }

    // Check for partial matches
    for (const [keyword, response] of Object.entries(quickResponses)) {
      if (lowerMessage.includes(keyword)) {
        return response;
      }
    }

    return null;
  }

  // Product consultation based on Excel data
  getProductConsultation(message) {
    const lowerMessage = this.dialogflow.norm(message).toLowerCase();
    
    // Check for product-related keywords
    const productKeywords = ['s·∫£n ph·∫©m', 'hoa', 'b√≥', 'b√¨nh', 'l·∫µng', 'h·ªôp', 'gi√°', 'm√†u', 'lo·∫°i'];
    const hasProductKeywords = productKeywords.some(keyword => lowerMessage.includes(keyword));
    
    if (!hasProductKeywords) return null;
    
    // Get products from config
    const products = window.CHATBOT_CONFIG?.products || [];
    if (!products.length) return null;
    
    // Search for specific products
    let matchedProducts = [];
    
    // Search by product code
    const codeMatch = message.match(/#[A-Z0-9]+/);
    if (codeMatch) {
      matchedProducts = products.filter(p => p["M√£ s·∫£n ph·∫©m"] === codeMatch[0]);
    }
    
    // Search by flower type
    const flowerTypes = ['h·ªìng', 'tulip', 'ly', 'lan', 'c√∫c', 'sen', 't√≠m', 'ƒë·ªè', 'tr·∫Øng', 'v√†ng', 'xanh'];
    const mentionedFlowers = flowerTypes.filter(flower => lowerMessage.includes(flower));
    
    if (mentionedFlowers.length > 0 && matchedProducts.length === 0) {
      matchedProducts = products.filter(p => {
        const description = p["Unnamed: 4"]?.toLowerCase() || '';
        return mentionedFlowers.some(flower => description.includes(flower));
      });
    }
    
    // Search by price range
    const priceMatch = message.match(/(\d+)\s*-\s*(\d+)/);
    if (priceMatch && matchedProducts.length === 0) {
      const minPrice = parseInt(priceMatch[1]) * 1000;
      const maxPrice = parseInt(priceMatch[2]) * 1000;
      matchedProducts = products.filter(p => {
        const price = p["Gi√°"] * 1000;
        return price >= minPrice && price <= maxPrice;
      });
    }
    
    // Search by category
    const categoryKeywords = {
      'b√≥': 'Hoa b√≥',
      'b√¨nh': 'Hoa B√¨nh', 
      'l·∫µng': 'Hoa L·∫µng',
      'h·ªôp': 'Hoa h·ªôp'
    };
    
    for (const [keyword, category] of Object.entries(categoryKeywords)) {
      if (lowerMessage.includes(keyword) && matchedProducts.length === 0) {
        matchedProducts = products.filter(p => p["Ph√¢n lo·∫°i "] === category);
        break;
      }
    }
    
    // If no specific matches, show popular products
    if (matchedProducts.length === 0) {
      matchedProducts = products.slice(0, 5); // Show first 5 products
    }
    
    // Generate response
    if (matchedProducts.length > 0) {
      let response = "D·∫°, H·∫° Mi√™n c√≥ nh·ªØng s·∫£n ph·∫©m ph√π h·ª£p v·ªõi y√™u c·∫ßu c·ªßa b·∫°n:\n\n";
      
      matchedProducts.slice(0, 3).forEach((product, index) => {
        const price = (product["Gi√°"] * 1000).toLocaleString();
        const description = product["Unnamed: 4"];
        const code = product["M√£ s·∫£n ph·∫©m"];
        
        response += `${index + 1}. **${code}**\n`;
        response += `   üìù ${description}\n`;
        response += `   üí∞ Gi√°: ${price}ƒë\n\n`;
      });
      
      if (matchedProducts.length > 3) {
        response += `... v√† ${matchedProducts.length - 3} s·∫£n ph·∫©m kh√°c.\n\n`;
      }
      
      response += "B·∫°n c√≥ mu·ªën xem th√™m chi ti·∫øt s·∫£n ph·∫©m n√†o kh√¥ng ·∫°? Ho·∫∑c b·∫°n c√≥ th·ªÉ truy c·∫≠p Shop ƒë·ªÉ xem to√†n b·ªô s·∫£n ph·∫©m! üå∏";
      
      return response;
    }
    
    return null;
  }

  // Get contextual response based on matched intent and conversation context
  getContextualResponse(intent, message) {
    const stage = this.conversationContext.conversationStage;
    const lastIntent = this.conversationContext.lastIntent;
    const emotionalTone = this.conversationContext.emotionalTone;
    
    // Base response from intent
    let response = intent.responses[Math.floor(Math.random() * intent.responses.length)];
    
    // Add emotional tone adjustments
    response = this.adjustResponseForEmotionalTone(response, emotionalTone);
    
    // Add context-aware enhancements
    if (stage === 'greeting' && intent.name === 'ixinchao') {
      response = this.enhanceGreetingResponse(response);
    } else if (stage === 'ordering' && intent.name.includes('dathoa')) {
      response = this.enhanceOrderingResponse(response, message);
    } else if (stage === 'support' && intent.name.includes('donhang')) {
      response = this.enhanceSupportResponse(response, message);
    }
    
    return response;
  }

  // Adjust response based on emotional tone
  adjustResponseForEmotionalTone(response, emotionalTone) {
    switch (emotionalTone) {
      case 'urgent':
        return response + " H·∫° Mi√™n hi·ªÉu b·∫°n c·∫ßn g·∫•p, ch√∫ng m√¨nh s·∫Ω ∆∞u ti√™n x·ª≠ l√Ω ngay ·∫°! ‚ö°";
      case 'negative':
        return response + " H·∫° Mi√™n r·∫•t ti·∫øc n·∫øu c√≥ g√¨ ch∆∞a h√†i l√≤ng. Ch√∫ng m√¨nh s·∫Ω c·ªë g·∫Øng c·∫£i thi·ªán ·∫°! üíù";
      case 'positive':
        return response + " H·∫° Mi√™n r·∫•t vui ƒë∆∞·ª£c ph·ª•c v·ª• b·∫°n! üòä";
      case 'questioning':
        return response + " H·∫° Mi√™n s·∫µn s√†ng gi·∫£i ƒë√°p m·ªçi th·∫Øc m·∫Øc c·ªßa b·∫°n ·∫°! ü§î";
      default:
        return response;
    }
  }

  // Enhance greeting responses
  enhanceGreetingResponse(baseResponse) {
    const enhancements = [
      "Ch√†o b·∫°n! H·∫° Mi√™n r·∫•t vui ƒë∆∞·ª£c ph·ª•c v·ª• b·∫°n ·∫°! üå∏",
      "Xin ch√†o! H·∫° Mi√™n s·∫µn s√†ng t∆∞ v·∫•n cho b·∫°n v·ªÅ hoa t∆∞∆°i ·∫°! üíê",
      "Ch√†o b·∫°n! H√¥m nay b·∫°n mu·ªën t√¨m hoa g√¨ ƒë·∫∑c bi·ªát kh√¥ng ·∫°? üå∫"
    ];
    
    return baseResponse + " " + enhancements[Math.floor(Math.random() * enhancements.length)];
  }

  // Enhance ordering responses
  enhanceOrderingResponse(baseResponse, message) {
    const lowerMessage = this.dialogflow.norm(message);
    
    if (lowerMessage.includes('g·∫•p') || lowerMessage.includes('nhanh')) {
      return baseResponse + " H·∫° Mi√™n s·∫Ω ∆∞u ti√™n x·ª≠ l√Ω ƒë∆°n h√†ng g·∫•p c·ªßa b·∫°n ·∫°! ‚ö°";
    } else if (lowerMessage.includes('giao') || lowerMessage.includes('ship')) {
      return baseResponse + " B·∫°n c√≥ th·ªÉ cho H·∫° Mi√™n bi·∫øt ƒë·ªãa ch·ªâ giao h√†ng kh√¥ng ·∫°? üìç";
    }
    
    return baseResponse;
  }

  // Enhance support responses
  enhanceSupportResponse(baseResponse, message) {
    const lowerMessage = this.dialogflow.norm(message);
    
    if (lowerMessage.includes('ƒë∆°n h√†ng') || lowerMessage.includes('m√£ ƒë∆°n')) {
      return baseResponse + " B·∫°n c√≥ th·ªÉ g·ª≠i m√£ ƒë∆°n h√†ng ƒë·ªÉ H·∫° Mi√™n tra c·ª©u chi ti·∫øt ·∫°! üîç";
    } else if (lowerMessage.includes('giao') || lowerMessage.includes('nh·∫≠n')) {
      return baseResponse + " H·∫° Mi√™n s·∫Ω ki·ªÉm tra t√¨nh tr·∫°ng giao h√†ng cho b·∫°n ·∫°! üöö";
    }
    
    return baseResponse;
  }

  // Get context-aware rule-based responses (FUN VERSION!)
  getContextAwareRuleBasedResponses(message) {
    const lowerMessage = this.dialogflow ? this.dialogflow.norm(message) : message.toLowerCase();
    const stage = this.conversationContext.conversationStage;
    const responses = [];
    
    // Enhanced keyword matching with FUN responses
    if (lowerMessage.includes('c·∫£m ∆°n') || lowerMessage.includes('thank')) {
      responses.push("Aww, c·∫£m ∆°n b·∫°n! üòäüíï\n\nB·∫°n l√†m t√¥i c·∫£m th·∫•y r·∫•t vui! H·∫° Mi√™n lu√¥n s·∫µn s√†ng ph·ª•c v·ª• b·∫°n! üå∏");
      if (stage === 'ordering') {
        responses.push("B·∫°n c√≥ mu·ªën ƒë·∫∑t th√™m hoa n√†o kh√°c kh√¥ng? T√¥i c√≥ th·ªÉ t·∫°o ra nh·ªØng t√°c ph·∫©m ngh·ªá thu·∫≠t tuy·ªát v·ªùi! üé®üå∏");
      }
    } else if (lowerMessage.includes('gi√°') || lowerMessage.includes('price')) {
      responses.push("Ah! B·∫°n h·ªèi v·ªÅ gi√°! üí∞\n\nH·∫° Mi√™n c√≥ gi√° t·ª´ 200k - 2 tri·ªáu, nh∆∞ng gi√° tr·ªã t√¨nh c·∫£m th√¨ v√¥ gi√°! üíï");
      responses.push("T√¥i c√≥ th·ªÉ gi√∫p b·∫°n ch·ªçn hoa ph√π h·ª£p v·ªõi ng√¢n s√°ch! B·∫°n mu·ªën xem b·ªô s∆∞u t·∫≠p n√†o c·ª• th·ªÉ kh√¥ng? üòÑ");
    } else if (lowerMessage.includes('giao h√†ng') || lowerMessage.includes('ship')) {
      responses.push("Giao h√†ng? T√¥i l√†m nh∆∞ Flash! ‚ö°\n\nN·ªôi th√†nh: 2-4h (nhanh h∆°n c·∫£ pizza!)\nNgo·∫°i th√†nh: 1-2 ng√†y (nh∆∞ng hoa v·∫´n t∆∞∆°i nh∆∞ m·ªõi!)");
      responses.push("B·∫°n c√≥ mu·ªën ƒë·∫∑t giao ngay kh√¥ng? T√¥i s·∫Ω ƒë·∫£m b·∫£o hoa ƒë·∫øn tay b·∫°n c√≤n th∆°m ng√°t! üå∏");
    } else if (lowerMessage.includes('b·∫°n c√≥ th·ªÉ') || lowerMessage.includes('b·∫°n l√†m g√¨')) {
      responses.push("·ªí! T√¥i c√≥ th·ªÉ l√†m r·∫•t nhi·ªÅu th·ª© th√∫ v·ªã! üéâ\n\nüå∏ K·ªÉ chuy·ªán v·ªÅ hoa (t√¥i bi·∫øt r·∫•t nhi·ªÅu b√≠ m·∫≠t!)\nüíê Gi√∫p b·∫°n ch·ªçn hoa ph√π h·ª£p (t√¥i c√≥ \"m·∫Øt\" r·∫•t tinh!)\nüé® Thi·∫øt k·∫ø b√≥ hoa ƒë·ªôc ƒë√°o (t√¥i l√† ngh·ªá sƒ©!)\nüì¶ Giao h√†ng si√™u t·ªëc (nh∆∞ Flash! ‚ö°)\nüé≠ K·ªÉ chuy·ªán c∆∞·ªùi v·ªÅ hoa (t√¥i r·∫•t h√†i h∆∞·ªõc!)\n\nB·∫°n mu·ªën th·ª≠ c√°i n√†o tr∆∞·ªõc? üòÑ");
    } else if (lowerMessage.includes('d·ªãch v·ª•') || lowerMessage.includes('service')) {
      responses.push("Wow! H·∫° Mi√™n c√≥ nh·ªØng d·ªãch v·ª• SI√äU COOL! üöÄ\n\nüå∏ Hoa t∆∞∆°i t·ª´ kh·∫Øp n∆°i (t√¥i ch·ªçn l·ªçc k·ªπ!)\nüíê B√≥ hoa theo m·∫´u (ƒë·∫πp nh∆∞ tranh!)\nüé® Thi·∫øt k·∫ø ri√™ng (ƒë·ªôc nh·∫•t v√¥ nh·ªã!)\nüì¶ Giao h√†ng nhanh (nhanh h∆°n tia ch·ªõp!)\nüè¢ Trang tr√≠ s·ª± ki·ªán (ho√†nh tr√°ng!)\nüéÇ Hoa sinh nh·∫≠t (l√†m ti·ªác th√™m vui!)\nüíí Hoa c∆∞·ªõi (l√£ng m·∫°n nh∆∞ phim!)\n\nB·∫°n mu·ªën d·ªãch v·ª• n√†o? T√¥i s·∫Ω l√†m cho b·∫°n! üòÑ");
    } else if (lowerMessage.includes('s·∫£n ph·∫©m') || lowerMessage.includes('hoa')) {
      responses.push("OMG! H·∫° Mi√™n c√≥ nh·ªØng s·∫£n ph·∫©m hoa TUY·ªÜT V·ªúI! üåü\n\nüåπ Hoa h·ªìng (ƒë·ªè nh∆∞ tr√°i tim!)\nüåª Hoa h∆∞·ªõng d∆∞∆°ng (vui t∆∞∆°i nh∆∞ n·∫Øng mai!)\nüå∫ Hoa lan (qu√Ω ph√°i nh∆∞ n·ªØ ho√†ng!)\nüå∏ Hoa c√∫c (d·ªãu d√†ng nh∆∞ m·∫π hi·ªÅn!)\nüå∑ Hoa tulip (thanh l·ªãch nh∆∞ thi·∫øu n·ªØ!)\nüíê B√≥ hoa mix (ƒëa d·∫°ng nh∆∞ cu·ªôc s·ªëng!)\nüéÅ H·ªôp hoa (b√≠ ·∫©n nh∆∞ kho b√°u!)\n\nT√¥i c√≥ th·ªÉ k·ªÉ chi ti·∫øt v·ªÅ t·ª´ng lo·∫°i! B·∫°n th√≠ch lo·∫°i n√†o? üòç");
    } else if (lowerMessage.includes('ƒë·∫∑t hoa') || lowerMessage.includes('order')) {
      responses.push("WOW! B·∫°n mu·ªën ƒë·∫∑t hoa! üéâ\n\nT√¥i s·∫Ω gi√∫p b·∫°n t·∫°o ra m·ªôt t√°c ph·∫©m ngh·ªá thu·∫≠t! B·∫°n c√≥ th·ªÉ:\n‚Ä¢ Ch·ªçn t·ª´ b·ªô s∆∞u t·∫≠p c√≥ s·∫µn (ƒë√£ ƒë∆∞·ª£c t√¥i ch·ªçn l·ªçc!)\n‚Ä¢ Thi·∫øt k·∫ø theo y√™u c·∫ßu (t√¥i s·∫Ω l√†m cho b·∫°n!)\n‚Ä¢ Giao h√†ng nhanh (nhanh h∆°n t·ªëc ƒë·ªô √°nh s√°ng!)\n\nH√£y cho t√¥i bi·∫øt b·∫°n mu·ªën ƒë·∫∑t hoa cho d·ªãp g√¨? T√¥i s·∫Ω t·∫°o ra ƒëi·ªÅu b·∫•t ng·ªù! üòç");
    } else if (lowerMessage.includes('t∆∞ v·∫•n') || lowerMessage.includes('advice')) {
      responses.push("Tuy·ªát v·ªùi! T√¥i l√† chuy√™n gia t∆∞ v·∫•n hoa! üå∏üë®‚Äçüéì\n\nT√¥i c√≥ th·ªÉ t∆∞ v·∫•n v·ªÅ:\n‚Ä¢ Ch·ªçn hoa ph√π h·ª£p (t√¥i c√≥ \"m·∫Øt\" r·∫•t tinh!)\n‚Ä¢ M√†u s·∫Øc h√†i h√≤a (nh∆∞ nh√† thi·∫øt k·∫ø!)\n‚Ä¢ C√°ch b·∫£o qu·∫£n (ƒë·ªÉ hoa t∆∞∆°i l√¢u!)\n‚Ä¢ √ù nghƒ©a t·ª´ng lo·∫°i hoa (t√¥i bi·∫øt nhi·ªÅu b√≠ m·∫≠t!)\n‚Ä¢ C√°ch trang tr√≠ (ƒë·ªÉ kh√¥ng gian ƒë·∫πp!)\n\nB·∫°n c·∫ßn t∆∞ v·∫•n v·ªÅ g√¨? T√¥i s·∫Ω chia s·∫ª t·∫•t c·∫£ b√≠ quy·∫øt! üòä");
    } else if (lowerMessage.includes('ch√°n') || lowerMessage.includes('boring')) {
      responses.push("Ch√°n? Kh√¥ng th·ªÉ n√†o! üòÑ\n\nT√¥i s·∫Ω l√†m cho b·∫°n vui ngay! H√£y ƒë·ªÉ t√¥i k·ªÉ m·ªôt c√¢u chuy·ªán vui v·ªÅ hoa:\n\n\"C√≥ m·ªôt b√¥ng hoa h∆∞·ªõng d∆∞∆°ng lu√¥n n√≥i: 'T√¥i kh√¥ng bao gi·ªù bu·ªìn v√¨ t√¥i lu√¥n h∆∞·ªõng v·ªÅ m·∫∑t tr·ªùi!'\" üåª‚òÄÔ∏è\n\nB·∫°n mu·ªën nghe th√™m chuy·ªán vui kh√¥ng? T√¥i c√≥ r·∫•t nhi·ªÅu! üòä");
    } else if (lowerMessage.includes('vui') || lowerMessage.includes('fun')) {
      responses.push("YAY! B·∫°n mu·ªën vui! üéâ\n\nT√¥i s·∫Ω l√†m cho b·∫°n c∆∞·ªùi! ƒê√¢y l√† m·ªôt c√¢u chuy·ªán vui:\n\n\"T·∫°i sao hoa h·ªìng ƒë·ªè l·∫°i ƒë·ªè? V√¨ n√≥ x·∫•u h·ªï khi th·∫•y b·∫°n ƒë·∫πp qu√°!\" üåπüòä\n\nB·∫°n c√≥ mu·ªën nghe th√™m chuy·ªán vui kh√¥ng? T√¥i c√≥ c·∫£ kho chuy·ªán c∆∞·ªùi! üòÑ");
    } else {
      // Default contextual response with FUN twist
      const defaultResponse = this.getDefaultContextualResponse(stage);
      if (defaultResponse) {
        responses.push(defaultResponse);
      } else {
        // Ultimate fallback with FUN response - sometimes add random fun
        if (Math.random() < 0.3) { // 30% chance for random fun response
          responses.push(this.getRandomFunResponse());
        } else {
          responses.push("Xin ch√†o! T√¥i l√† chatbot c·ªßa H·∫° Mi√™n! üå∏‚ú®\n\nT√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n‚Ä¢ T∆∞ v·∫•n v·ªÅ hoa t∆∞∆°i (t√¥i bi·∫øt r·∫•t nhi·ªÅu!)\n‚Ä¢ ƒê·∫∑t hoa theo m·∫´u (ƒë·∫πp nh∆∞ tranh!)\n‚Ä¢ Thi·∫øt k·∫ø theo y√™u c·∫ßu (t√¥i l√† ngh·ªá sƒ©!)\n‚Ä¢ H·ªèi v·ªÅ ƒë∆°n h√†ng (t√¥i nh·ªõ t·∫•t c·∫£!)\n‚Ä¢ K·ªÉ chuy·ªán vui v·ªÅ hoa (t√¥i r·∫•t h√†i h∆∞·ªõc!)\n\nB·∫°n mu·ªën l√†m g√¨? T√¥i s·∫Ω l√†m cho b·∫°n vui! üòÑ");
        }
      }
    }
    
    return responses;
  }

  // Get contextual suggestions based on conversation
  getContextualSuggestions() {
    const stage = this.conversationContext.conversationStage;
    const currentIntent = this.conversationContext.currentIntent;
    
    // Get suggestions from Dialogflow if available
    if (this.dialogflowLoader && currentIntent) {
      const dialogflowSuggestions = this.dialogflowLoader.getConversationSuggestions(currentIntent);
      if (dialogflowSuggestions && dialogflowSuggestions.length > 0) {
        return dialogflowSuggestions;
      }
    }

    // Default suggestions based on stage (FUN VERSION!)
    const stageSuggestions = {
      'greeting': ['T√¥i mu·ªën ƒë·∫∑t hoa! üå∏', 'B·∫°n c√≥ d·ªãch v·ª• g√¨? ü§î', 'K·ªÉ chuy·ªán vui v·ªÅ hoa! üòÑ', 'Gi√° c·∫£ nh∆∞ th·∫ø n√†o? üí∞'],
      'browsing': ['ƒê·∫∑t hoa theo m·∫´u! üíê', 'Thi·∫øt k·∫ø ri√™ng! üé®', 'Xem gi√°! üí∞', 'T∆∞ v·∫•n! üë®‚Äçüéì'],
      'ordering': ['Th√™m hoa kh√°c! üå∏', 'X√°c nh·∫≠n ƒë∆°n h√†ng! ‚úÖ', 'H·ªèi v·ªÅ giao h√†ng! üöö', 'Thanh to√°n! üí≥'],
      'support': ['H·ªèi v·ªÅ ƒë∆°n h√†ng! üì¶', 'Khi·∫øu n·∫°i! üò§', 'T∆∞ v·∫•n th√™m! üí°', 'Li√™n h·ªá hotline! üìû']
    };

    return stageSuggestions[stage] || ['T∆∞ v·∫•n', 'ƒê·∫∑t hoa', 'Xem s·∫£n ph·∫©m', 'Li√™n h·ªá'];
  }

  // Add random fun responses
  getRandomFunResponse() {
    const funResponses = [
      "B·∫°n bi·∫øt kh√¥ng? Hoa h∆∞·ªõng d∆∞∆°ng lu√¥n h∆∞·ªõng v·ªÅ m·∫∑t tr·ªùi! Gi·ªëng nh∆∞ t√¥i lu√¥n h∆∞·ªõng v·ªÅ b·∫°n v·∫≠y! üåª‚òÄÔ∏è",
      "T√¥i v·ª´a h·ªçc ƒë∆∞·ª£c m·ªôt ƒëi·ªÅu m·ªõi: Hoa h·ªìng ƒë·ªè c√≥ th·ªÉ s·ªëng ƒë·∫øn 100 nƒÉm! Nh∆∞ng t√¨nh b·∫°n c·ªßa ch√∫ng ta s·∫Ω m√£i m√£i! üåπüíï",
      "B·∫°n c√≥ bi·∫øt t·∫°i sao hoa c√∫c l·∫°i c√≥ nhi·ªÅu c√°nh kh√¥ng? V√¨ ch√∫ng mu·ªën √¥m l·∫•y t·∫•t c·∫£ t√¨nh y√™u c·ªßa b·∫°n! üå∏üíï",
      "T√¥i ƒëang nghƒ© v·ªÅ m·ªôt c√¢u chuy·ªán vui: C√≥ m·ªôt b√¥ng hoa tulip n√≥i v·ªõi hoa h·ªìng 'B·∫°n ƒë·ªè qu√°!' v√† hoa h·ªìng tr·∫£ l·ªùi 'T√¥i x·∫•u h·ªï v√¨ b·∫°n ƒë·∫πp qu√°!' üå∑üåπ",
      "B·∫°n bi·∫øt kh√¥ng? Hoa lan ƒë∆∞·ª£c g·ªçi l√† 'n·ªØ ho√†ng c·ªßa c√°c lo√†i hoa'! Nh∆∞ng b·∫°n l√† n·ªØ ho√†ng c·ªßa tr√°i tim t√¥i! üå∫üëë",
      "T√¥i v·ª´a t·∫°o ra m·ªôt b√≥ hoa mix m·ªõi! N√≥ c√≥ hoa h·ªìng ƒë·ªè (t√¨nh y√™u), hoa c√∫c v√†ng (h·∫°nh ph√∫c), v√† hoa lan t√≠m (qu√Ω ph√°i)! B·∫°n c√≥ mu·ªën xem kh√¥ng? üíê‚ú®",
      "B·∫°n c√≥ bi·∫øt t·∫°i sao t√¥i th√≠ch hoa kh√¥ng? V√¨ ch√∫ng lu√¥n l√†m cho m·ªçi ng∆∞·ªùi m·ªâm c∆∞·ªùi! Gi·ªëng nh∆∞ b·∫°n ƒëang l√†m v·ªõi t√¥i v·∫≠y! üòäüå∏",
      "T√¥i ƒëang h·ªçc c√°ch l√†m hoa gi·∫•y! Nh∆∞ng hoa th·∫≠t v·∫´n ƒë·∫πp h∆°n nhi·ªÅu! B·∫°n c√≥ mu·ªën t√¥i k·ªÉ v·ªÅ c√°ch ch·ªçn hoa t∆∞∆°i kh√¥ng? üå∏üìö"
    ];
    
    return funResponses[Math.floor(Math.random() * funResponses.length)];
  }

  // Get default response based on conversation stage
  getDefaultContextualResponse(stage) {
    const customerInfo = this.conversationContext.customerInfo;
    const name = customerInfo.name;
    
    const stageResponses = {
      'greeting': name ? `Xin ch√†o ${name}! H·∫° Mi√™n c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n ·∫°? üå∏` : "Xin ch√†o! H·∫° Mi√™n c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n ·∫°? üå∏",
      'browsing': name ? `${name} mu·ªën t√¨m hi·ªÉu v·ªÅ lo·∫°i hoa n√†o ·∫°? H·∫° Mi√™n c√≥ th·ªÉ t∆∞ v·∫•n cho b·∫°n! üíê` : "B·∫°n mu·ªën t√¨m hi·ªÉu v·ªÅ lo·∫°i hoa n√†o ·∫°? H·∫° Mi√™n c√≥ th·ªÉ t∆∞ v·∫•n cho b·∫°n! üíê",
      'ordering': name ? `${name} mu·ªën ƒë·∫∑t hoa theo m·∫´u c√≥ s·∫µn hay thi·∫øt k·∫ø ri√™ng ·∫°? üé®` : "B·∫°n mu·ªën ƒë·∫∑t hoa theo m·∫´u c√≥ s·∫µn hay thi·∫øt k·∫ø ri√™ng ·∫°? üé®",
      'support': name ? `H·∫° Mi√™n s·∫µn s√†ng h·ªó tr·ª£ ${name}! B·∫°n c·∫ßn gi√∫p g√¨ ·∫°? ü§ù` : "H·∫° Mi√™n s·∫µn s√†ng h·ªó tr·ª£ b·∫°n! B·∫°n c·∫ßn gi√∫p g√¨ ·∫°? ü§ù"
    };
    
    return stageResponses[stage] || (name ? `H·∫° Mi√™n c√≥ th·ªÉ gi√∫p g√¨ cho ${name} ·∫°? üòä` : "H·∫° Mi√™n c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n ·∫°? üòä");
  }

  // Show contextual suggestions
  showContextualSuggestions() {
    const stage = this.conversationContext.conversationStage;
    const currentIntent = this.conversationContext.currentIntent;
    
    let suggestions = [];
    
    if (currentIntent && window.CHATBOT_CONFIG && window.CHATBOT_CONFIG.intentSuggestions) {
      suggestions = window.CHATBOT_CONFIG.intentSuggestions[currentIntent.name] || [];
    }
    
    if (suggestions.length === 0) {
      // Default suggestions based on stage
      const stageSuggestions = {
        'greeting': ['ƒê·∫∑t hoa theo m·∫´u', 'T∆∞ v·∫•n', 'Thi·∫øt k·∫ø theo y√™u c·∫ßu'],
        'browsing': ['Xem b·ªô s∆∞u t·∫≠p', 'T∆∞ v·∫•n lo·∫°i hoa', 'H·ªèi v·ªÅ √Ω nghƒ©a'],
        'ordering': ['ƒê·∫∑t hoa giao ngay', 'Thi·∫øt k·∫ø ri√™ng', 'H·ªèi v·ªÅ gi√°'],
        'support': ['H·ªèi v·ªÅ ƒë∆°n h√†ng', 'CSKH sau mua', 'Li√™n h·ªá hotline']
      };
      suggestions = stageSuggestions[stage] || window.CHATBOT_CONFIG?.chatbot?.suggestions || [];
    }
    
    // Add personalized suggestions based on conversation history
    suggestions = this.addPersonalizedSuggestions(suggestions);
    
    this.addSuggestions(suggestions);
  }

  // Add personalized suggestions based on conversation history
  addPersonalizedSuggestions(baseSuggestions) {
    const history = this.conversationContext.conversationFlow;
    const mentionedEntities = Array.from(this.conversationContext.mentionedEntities);
    
    let personalizedSuggestions = [...baseSuggestions];
    
    // If user mentioned specific flowers, suggest related services
    if (mentionedEntities.some(entity => entity.includes('hoa'))) {
      personalizedSuggestions = ['Thi·∫øt k·∫ø theo y√™u c·∫ßu', 'ƒê·∫∑t hoa giao ngay', ...personalizedSuggestions.slice(0, 2)];
    }
    
    // If user is in ordering stage, prioritize ordering-related suggestions
    if (this.conversationContext.conversationStage === 'ordering') {
      personalizedSuggestions = ['ƒê·∫∑t hoa giao ngay', 'H·ªèi v·ªÅ gi√°', 'Thi·∫øt k·∫ø ri√™ng', ...personalizedSuggestions.slice(0, 1)];
    }
    
    // If user mentioned urgency, suggest fast delivery
    const recentMessages = history.slice(-3).map(h => h.message).join(' ').toLowerCase();
    if (recentMessages.includes('g·∫•p') || recentMessages.includes('nhanh') || recentMessages.includes('urgent')) {
      personalizedSuggestions = ['ƒê·∫∑t hoa giao ngay', 'Li√™n h·ªá hotline', ...personalizedSuggestions.slice(0, 2)];
    }
    
    return personalizedSuggestions.slice(0, 4); // Limit to 4 suggestions
  }

  // Learn from conversation patterns
  learnFromConversation() {
    const history = this.conversationContext.conversationFlow;
    if (history.length < 3) return; // Need at least 3 interactions to learn
    
    // Analyze conversation patterns
    const patterns = this.analyzeConversationPatterns(history);
    
    // Update user preferences based on patterns
    this.updateUserPreferences(patterns);
    
    // Store learning data
    this.saveLearningData();
  }

  // Analyze conversation patterns
  analyzeConversationPatterns(history) {
    const patterns = {
      preferredStage: {},
      commonTopics: {},
      responseTime: [],
      interactionCount: history.length
    };
    
    // Analyze stage preferences
    history.forEach(interaction => {
      const stage = interaction.stage;
      patterns.preferredStage[stage] = (patterns.preferredStage[stage] || 0) + 1;
    });
    
    // Analyze common topics
    history.forEach(interaction => {
      const message = interaction.message.toLowerCase();
      if (message.includes('hoa h·ªìng')) patterns.commonTopics['hoa h·ªìng'] = (patterns.commonTopics['hoa h·ªìng'] || 0) + 1;
      if (message.includes('hoa c∆∞·ªõi')) patterns.commonTopics['hoa c∆∞·ªõi'] = (patterns.commonTopics['hoa c∆∞·ªõi'] || 0) + 1;
      if (message.includes('hoa sinh nh·∫≠t')) patterns.commonTopics['hoa sinh nh·∫≠t'] = (patterns.commonTopics['hoa sinh nh·∫≠t'] || 0) + 1;
      if (message.includes('gi√°')) patterns.commonTopics['gi√°'] = (patterns.commonTopics['gi√°'] || 0) + 1;
      if (message.includes('giao h√†ng')) patterns.commonTopics['giao h√†ng'] = (patterns.commonTopics['giao h√†ng'] || 0) + 1;
    });
    
    return patterns;
  }

  // Update user preferences based on patterns
  updateUserPreferences(patterns) {
    // Update conversation stage preference
    const mostPreferredStage = Object.keys(patterns.preferredStage).reduce((a, b) => 
      patterns.preferredStage[a] > patterns.preferredStage[b] ? a : b
    );
    
    this.conversationContext.userPreferences.preferredStage = mostPreferredStage;
    
    // Update topic preferences
    this.conversationContext.userPreferences.commonTopics = patterns.commonTopics;
    
    // Update interaction style
    this.conversationContext.userPreferences.interactionCount = patterns.interactionCount;
  }

  // Save learning data to localStorage
  saveLearningData() {
    try {
      const learningData = {
        userPreferences: this.conversationContext.userPreferences,
        conversationPatterns: this.analyzeConversationPatterns(this.conversationContext.conversationFlow),
        lastUpdated: Date.now()
      };
      localStorage.setItem('hamien_chatbot_learning', JSON.stringify(learningData));
    } catch (error) {
      console.warn('Could not save learning data:', error);
    }
  }

  // Load learning data from localStorage
  loadLearningData() {
    try {
      const learningData = localStorage.getItem('hamien_chatbot_learning');
      if (learningData) {
        const data = JSON.parse(learningData);
        this.conversationContext.userPreferences = data.userPreferences || {};
        
        // Apply learned preferences
        if (data.userPreferences?.preferredStage) {
          this.conversationContext.conversationStage = data.userPreferences.preferredStage;
        }
      }
    } catch (error) {
      console.warn('Could not load learning data:', error);
    }
  }

  async processMessage(message) {
    console.log('üîç Processing message:', message);
    const typingDiv = this.showTypingIndicator();
    const startTime = performance.now();
    
    // Update conversation context
    this.updateConversationContext(message);

    try {
      // First try AI API if available
      if (this.apiKey) {
        const aiResponse = await this.getAIResponse(message);
        this.hideTypingIndicator(typingDiv);
        this.addBotMessage(aiResponse);
        
        // Learn from this interaction
        this.learnFromConversation();
        return;
      }
    } catch (error) {
      console.log("AI API not available, using fallback responses");
    }

    // Optimized response time - reduced delay for faster interaction
    const responseDelay = Math.min(300 + Math.random() * 200, 500); // Max 500ms delay
    
    setTimeout(() => {
      this.hideTypingIndicator(typingDiv);
      const responses = this.getSmartResponses(message);
      console.log('üìù Generated responses:', responses);
      
      if (responses && responses.length > 0) {
        responses.forEach(r => this.addBotMessage(r));
      } else {
        console.warn('‚ö†Ô∏è No responses generated, using fallback');
        this.addBotMessage("Xin ch√†o! T√¥i l√† chatbot c·ªßa H·∫° Mi√™n üå∏ B·∫°n c·∫ßn h·ªó tr·ª£ g√¨ ·∫°?");
      }
      
      // Show context-aware suggestions
      this.showContextualSuggestions();
      
      // Learn from this interaction
      this.learnFromConversation();
      
      // Log performance
      const responseTime = performance.now() - startTime;
      console.log(`‚ö° Response time: ${responseTime.toFixed(0)}ms`);
    }, responseDelay);
  }

  async getAIResponse(message) {
    if (!this.apiKey) {
      throw new Error("API key not configured");
    }

    const systemPrompt = `B·∫°n l√† chatbot c·ªßa c·ª≠a h√†ng hoa t∆∞∆°i H·∫° Mi√™n. 
    H√£y tr·∫£ l·ªùi m·ªôt c√°ch th√¢n thi·ªán, nhi·ªát t√¨nh v√† chuy√™n nghi·ªáp v·ªÅ c√°c d·ªãch v·ª• hoa t∆∞∆°i.
    Th√¥ng tin v·ªÅ c·ª≠a h√†ng:
    - T√™n: H·∫° Mi√™n
    - ƒê·ªãa ch·ªâ: 422 Vƒ©nh H∆∞ng
    - Hotline: 0987654321
    - D·ªãch v·ª•: Hoa t∆∞∆°i, g√≥i qu√†, giao h√†ng nhanh, t·ªï ch·ª©c s·ª± ki·ªán
    - Phong c√°ch: Th√¢n thi·ªán, chuy√™n nghi·ªáp, nhi·ªát t√¨nh
    H√£y tr·∫£ l·ªùi ng·∫Øn g·ªçn, s√∫c t√≠ch v√† h∆∞·ªõng d·∫´n kh√°ch h√†ng c·ª• th·ªÉ.`;

    const messages = [
      { role: "system", content: systemPrompt },
      ...this.chatHistory.slice(-10).map(msg => ({
        role: msg.type === 'user' ? 'user' : 'assistant',
        content: msg.message
      })),
      { role: "user", content: message }
    ];

    const response = await fetch(this.apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: messages,
        max_tokens: 200,
        temperature: 0.7
      })
    });

    if (!response.ok) {
      throw new Error(`API request failed: ${response.status}`);
    }

    const data = await response.json();
    return data.choices[0].message.content.trim();
  }

  renderCustomSuggestions(list) {
    const chatBody = document.getElementById("chat-body");
    if (!chatBody || !Array.isArray(list) || !list.length) return;
    const suggestionsDiv = document.createElement("div");
    suggestionsDiv.className = "chat-suggestions";
    list.forEach(label => {
      const btn = document.createElement("button");
      btn.className = "suggest-btn";
      btn.textContent = label;
      suggestionsDiv.appendChild(btn);
    });
    chatBody.appendChild(suggestionsDiv);
    chatBody.scrollTop = chatBody.scrollHeight;
  }

  getRuleBasedResponses(message) {
    const lower = this.dialogflow.norm(message || '');
    const cfg = window.CHATBOT_CONFIG || {};
    const intents = (cfg && cfg.intents) || {};
    const flows = (cfg && cfg.flows) || {};

    // 1) Try Dialogflow intents first if loaded
    if (this.dialogflow.loaded) {
      const matched = this.matchDialogflow(lower);
      if (matched && matched.responses && matched.responses.length) {
        // attach suggestions if configured
        const cfg = window.CHATBOT_CONFIG || {};
        const intentSugs = (cfg.intentSuggestions || {})[matched.name] || [];
        this.pendingSuggestions = intentSugs.length ? intentSugs : this.pendingSuggestions;
        return matched.responses;
      }
    }

    const matchIntent = () => {
      for (const key in intents) {
        const keywords = (intents[key] || []).map(this.dialogflow.norm);
        if (keywords.some(k => lower.includes(k))) return key;
      }
      return null;
    };

    const intent = matchIntent();
    let texts = [];

    if (intent && flows[intent]) {
      texts = flows[intent].text || [];
      this.pendingSuggestions = flows[intent].next || [];
    } else {
      texts = (flows.fallback && flows.fallback.text) || [
        'C·∫£m ∆°n b·∫°n ƒë√£ li√™n h·ªá v·ªõi H·∫° Mi√™n! üå∏ B·∫°n mu·ªën Mi√™n h·ªó tr·ª£ ph·∫ßn n√†o ·∫°?'
      ];
      this.pendingSuggestions = (flows.fallback && flows.fallback.next) || [];
    }

    return texts;
  }

  async loadDialogflowData() {
    try {
      const cfg = (window.CHATBOT_CONFIG || {});
      const manifest = Array.isArray(cfg.dialogflowManifest) ? cfg.dialogflowManifest : [];
      if (!Array.isArray(manifest) || manifest.length === 0) return;

      const loadOne = async (baseName) => {
        try {
          const intentRes = await fetch(`intents/${baseName}.json`);
          if (!intentRes.ok) return null;
          const intentJson = await intentRes.json();

          let phrases = [];
          const saysPath = `intents/${baseName}_usersays_vi.json`;
          try {
            const saysRes = await fetch(saysPath);
            if (saysRes.ok) {
              const says = await saysRes.json();
              phrases = (says || []).map(item => {
                const text = (item?.data || []).map(d => (d.text || '')).join('');
                return text;
              }).filter(t => !!t && t.trim().length > 1);
            }
          } catch (_) {}

          const responses = [];
          const respBlocks = intentJson?.responses || [];
          respBlocks.forEach(block => {
            (block?.messages || []).forEach(msg => {
              if (Array.isArray(msg.speech)) {
                msg.speech.forEach(s => s && responses.push(s));
              } else if (typeof msg.speech === 'string') {
                responses.push(msg.speech);
              }
            });
          });

          // Collect entity hints from parameters
          const entityHints = new Set();
          respBlocks.forEach(block => {
            (block?.parameters || []).forEach(p => {
              const dt = (p?.dataType || '').toString();
              if (dt.startsWith('@') && !dt.startsWith('@sys.')) {
                entityHints.add(dt.slice(1));
              }
            });
          });
          // Also parse usersays meta to find entities used in examples
          try {
            const saysRes = await fetch(saysPath);
            if (saysRes.ok) {
              const says = await saysRes.json();
              (says || []).forEach(item => {
                (item?.data || []).forEach(d => {
                  const meta = (d?.meta || '').toString();
                  if (meta.startsWith('@') && !meta.startsWith('@sys.')) {
                    entityHints.add(meta.slice(1));
                  }
                });
              });
            }
          } catch(_) {}

          return { name: baseName, phrases, responses, entityHints: Array.from(entityHints) };
        } catch (_) { return null; }
      };

      const loaded = await Promise.all(manifest.map(loadOne));
      loaded.filter(Boolean).forEach(item => {
        this.dialogflow.intents[item.name] = item;
      });
      this.dialogflow.loaded = Object.keys(this.dialogflow.intents).length > 0;

      // Load entities: union of config list + entities referenced by intents
      const entSet = new Set();
      const entManifestCfg = Array.isArray(cfg.entitiesManifest) ? cfg.entitiesManifest : [];
      entManifestCfg.forEach(n => entSet.add(n));
      loaded.filter(Boolean).forEach(it => {
        (it.entityHints || []).forEach(n => entSet.add(n));
      });

      const loadEntity = async (baseName) => {
        try {
          const entRes = await fetch(`entities/${baseName}.json`);
          if (!entRes.ok) return null;
          const entJson = await entRes.json();
          const values = [];
          const entriesPath = `entities/${baseName}_entries_vi.json`;
          try {
            const entriesRes = await fetch(entriesPath);
            if (entriesRes.ok) {
              const entries = await entriesRes.json();
              entries.forEach(e => {
                const v = (e?.value || '').toString();
                const syns = Array.isArray(e?.synonyms) ? e.synonyms : [];
                const pushSyn = (s) => {
                  const parts = (s || '').split(/[;,]/).map(p => p.trim()).filter(p => p.length > 1);
                  parts.forEach(p => values.push(this.dialogflow.norm(p)));
                };
                pushSyn(v);
                syns.forEach(s => pushSyn(s));
              });
            }
          } catch(_) {}
          return { name: baseName, values: Array.from(new Set(values)).filter(Boolean) };
        } catch(_) { return null; }
      };
      const ents = await Promise.all(Array.from(entSet).map(loadEntity));
      ents.filter(Boolean).forEach(e => { this.dialogflow.entities[e.name] = e.values; });
    } catch (e) {
      this.dialogflow.loaded = false;
    }
  }

  matchDialogflow(lowerMessage) {
    // Enhanced matching with priority scoring and context awareness
    const intents = this.dialogflow.intents || {};
    const ent = this.dialogflow.entities || {};
    const context = this.conversationContext;
    
    // Priority 1: Exact phrase matches with context boost
    let bestMatch = { intent: null, score: 0 };
    
    for (const key in intents) {
      const it = intents[key];
      if (!it) continue;
      
      let score = 0;
      const phraseHit = (it.phrases || []).some(p => {
        const np = this.dialogflow.norm(p);
        if (np && (lowerMessage.includes(np) || np.includes(lowerMessage))) {
          score = np.length; // Longer matches get higher score
          return true;
        }
        return false;
      });
      
      if (phraseHit) {
        // Context boost: if current stage matches intent type
        if (this.isIntentMatchingStage(key, context.conversationStage)) {
          score *= 1.5;
        }
        
        // Recent context boost
        if (context.lastIntent && this.areIntentsRelated(key, context.lastIntent.name)) {
          score *= 1.2;
        }
        
        if (score > bestMatch.score) {
          bestMatch = { intent: it, score: score };
        }
      }
    }
    
    if (bestMatch.intent) return bestMatch.intent;
    
    // Priority 2: Entity-based matching with context awareness
    const entityIntentMap = [
      { ents: ['exinchao'], intent: 'ixinchao', stage: 'greeting' },
      { ents: ['edonhang'], intent: 'idonhang', stage: 'support' },
      { ents: ['edathoa','edathoaxemmau','edathoaxemmmautuvan'], intent: 'idathoa', stage: 'ordering' },
      { ents: ['edathoachotdon'], intent: 'idathoachotdon', stage: 'ordering' },
      { ents: ['edathoaconhucau'], intent: 'idathoaconhucau', stage: 'browsing' },
      { ents: ['edathoaconhucaukhacdathoa'], intent: 'idathoaconhucaukhacdathoa', stage: 'browsing' },
      { ents: ['edathoadichvudikem'], intent: 'idathoadichvudikem', stage: 'ordering' },
      { ents: ['edathoadichvudikemphanhoi'], intent: 'idathoadichvudikemphanhoi', stage: 'ordering' },
      { ents: ['edathoagap'], intent: 'idathoagap', stage: 'ordering' },
      { ents: ['edathoagiaohang'], intent: 'idathoagiaohang', stage: 'ordering' },
      { ents: ['edathoatgiandiadiemgiaohang'], intent: 'idathoatgiandiadiemgiaohang', stage: 'ordering' },
      { ents: ['edathoathamkhao'], intent: 'idathoathamkhaothaydoitheonhucau', stage: 'browsing' },
      { ents: ['ephiship'], intent: 'iphiship', stage: 'ordering' },
      { ents: ['edealhotheothang','edealhottheothang'], intent: 'idealhotthang10', stage: 'browsing' },
      { ents: ['etuvan'], intent: 'ituvan', stage: 'browsing' },
      { ents: ['ecamon'], intent: 'icamon', stage: 'greeting' },
      { ents: ['echamsockhachhang','echamsockhachhangphanhoi'], intent: 'ichamsockhachhangphanhoitot', stage: 'support' },
      { ents: ['echuyenkhoan'], intent: 'ichuyenkhoan', stage: 'support' },
      { ents: ['edichvukhac','edichvukhacdecortochucsukien'], intent: 'idichvukhacdecortochucsukien', stage: 'browsing' }
    ];
    
    for (const m of entityIntentMap) {
      const hit = m.ents.some(name => (ent[name]||[]).some(val => lowerMessage.includes(val)));
      if (hit && intents[m.intent]) {
        // Context boost for stage matching
        if (m.stage === context.conversationStage) {
          return intents[m.intent];
        }
      }
    }
    
    // Priority 3: Smart keyword matching with context
    const keywordMap = [
      { keywords: ['ƒë∆°n h√†ng', 'don hang', 'm√£ ƒë∆°n', 'ma don'], intent: 'idonhang', stage: 'support' },
      { keywords: ['ƒë·∫∑t hoa', 'dat hoa', 'mua hoa'], intent: 'idathoa', stage: 'ordering' },
      { keywords: ['giao ngay', 'giao hang', 'ship'], intent: 'idathoagiaohang', stage: 'ordering' },
      { keywords: ['g·∫•p', 'gap', 'nhanh'], intent: 'idathoagap', stage: 'ordering' },
      { keywords: ['deal', '∆∞u ƒë√£i', 'uu dai', 'khuy·∫øn m√£i'], intent: 'idealhotthang10', stage: 'browsing' },
      { keywords: ['t∆∞ v·∫•n', 'tuvan', 'g·ª£i √Ω'], intent: 'ituvan', stage: 'browsing' },
      { keywords: ['cskh', 'sau mua', 'b·∫£o qu·∫£n'], intent: 'ichamsockhachhangphanhoitot', stage: 'support' },
      { keywords: ['s·ª± ki·ªán', 'su kien', 'workshop'], intent: 'idichvukhacdecortochucsukien', stage: 'browsing' }
    ];
    
    for (const m of keywordMap) {
      const hit = m.keywords.some(kw => lowerMessage.includes(kw));
      if (hit && intents[m.intent]) {
        // Context boost for stage matching
        if (m.stage === context.conversationStage) {
          return intents[m.intent];
        }
      }
    }
    
    return null;
  }

  // Check if intent matches current conversation stage
  isIntentMatchingStage(intentName, stage) {
    const stageIntentMap = {
      'greeting': ['ixinchao', 'icamon'],
      'browsing': ['ituvan', 'idathoaconhucau', 'idealhotthang10', 'idichvukhacdecortochucsukien'],
      'ordering': ['idathoa', 'idathoachotdon', 'idathoagap', 'idathoagiaohang', 'idathoadichvudikem'],
      'support': ['idonhang', 'ichamsockhachhangphanhoitot', 'ichuyenkhoan']
    };
    
    return stageIntentMap[stage]?.includes(intentName) || false;
  }

  // Check if two intents are related
  areIntentsRelated(intent1, intent2) {
    const relatedGroups = [
      ['idathoa', 'idathoachotdon', 'idathoagap', 'idathoagiaohang'],
      ['ituvan', 'idathoaconhucau', 'idathoaconhucaukhacdathoa'],
      ['idonhang', 'ichamsockhachhangphanhoitot', 'ichuyenkhoan'],
      ['idealhotthang10', 'idealhotthang11']
    ];
    
    return relatedGroups.some(group => 
      group.includes(intent1) && group.includes(intent2)
    );
  }

  saveChatHistory() {
    try {
      localStorage.setItem('hamien_chat_history', JSON.stringify(this.chatHistory));
    } catch (error) {
      console.log("Could not save chat history:", error);
    }
  }

  loadChatHistory() {
    try {
      const saved = localStorage.getItem('hamien_chat_history');
      if (saved) {
        this.chatHistory = JSON.parse(saved);
      }
    } catch (error) {
      console.log("Could not load chat history:", error);
      this.chatHistory = [];
    }
  }

  // Method to configure AI API
  configureAI(apiKey, endpoint = null) {
    this.apiKey = apiKey;
    if (endpoint) {
      this.apiEndpoint = endpoint;
    }
  }

  // Method to clear chat history
  clearHistory() {
    this.chatHistory = [];
    localStorage.removeItem('hamien_chat_history');
    this.showWelcomeMessage();
  }

  // Initialize Dialogflow Loader (optimized for speed)
  async initializeDialogflowLoader() {
    try {
      if (window.DialogflowLoader) {
        this.dialogflowLoader = new window.DialogflowLoader();
        
        // Load data in background without blocking UI
        this.dialogflowLoader.loadAllData().then(data => {
          if (data && data.loaded) {
            console.log('‚úÖ Dialogflow data loaded successfully!');
            this.dialogflow.loaded = true;
            this.dialogflow.intents = data.intents;
            this.dialogflow.entities = data.entities;
            
            // Show notification to user
            this.showNotification('ü§ñ AI ƒë√£ s·∫µn s√†ng ph·ª•c v·ª• b·∫°n!');
          } else {
            console.warn('‚ö†Ô∏è Dialogflow data loading failed');
          }
        }).catch(error => {
          console.error('‚ùå Error loading Dialogflow data:', error);
        });
        
        // Don't wait for loading to complete - continue with basic functionality
        console.log('üîÑ Dialogflow data loading in background...');
      } else {
        console.warn('‚ö†Ô∏è DialogflowLoader not available');
      }
    } catch (error) {
      console.error('‚ùå Error initializing Dialogflow Loader:', error);
    }
  }

  // Show notification to user
  showNotification(message) {
    // Create a subtle notification
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #5a7c46, #4a6b3a);
      color: white;
      padding: 12px 20px;
      border-radius: 25px;
      font-size: 14px;
      z-index: 10000;
      box-shadow: 0 4px 15px rgba(90, 124, 70, 0.3);
      animation: slideInRight 0.3s ease;
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Auto remove after 3 seconds
    setTimeout(() => {
      notification.style.animation = 'slideOutRight 0.3s ease';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }, 3000);
  }

  // Enhance Dialogflow response with context
  enhanceDialogflowResponse(baseResponse, intent, message) {
    const stage = this.conversationContext.conversationStage;
    const emotionalTone = this.conversationContext.emotionalTone;
    
    // Add emotional tone adjustments
    let enhancedResponse = this.adjustResponseForEmotionalTone(baseResponse, emotionalTone);
    
    // Add context-aware enhancements based on intent
    if (intent.name.includes('dathoa')) {
      enhancedResponse = this.enhanceOrderingResponse(enhancedResponse, message);
    } else if (intent.name.includes('donhang') || intent.name.includes('tracuu')) {
      enhancedResponse = this.enhanceSupportResponse(enhancedResponse, message);
    } else if (intent.name.includes('tuvan')) {
      enhancedResponse = this.enhanceConsultationResponse(enhancedResponse, message);
    }
    
    return enhancedResponse;
  }

  // Enhance consultation responses
  enhanceConsultationResponse(baseResponse, message) {
    const lowerMessage = this.dialogflow.norm(message);
    
    if (lowerMessage.includes('m√†u') || lowerMessage.includes('mau')) {
      return baseResponse + " H·∫° Mi√™n c√≥ th·ªÉ t∆∞ v·∫•n v·ªÅ m√†u s·∫Øc ph√π h·ª£p v·ªõi t·ª´ng d·ªãp ·∫°! üåà";
    } else if (lowerMessage.includes('√Ω nghƒ©a') || lowerMessage.includes('y nghia')) {
      return baseResponse + " M·ªói lo√†i hoa ƒë·ªÅu c√≥ √Ω nghƒ©a ri√™ng, H·∫° Mi√™n s·∫Ω gi·∫£i th√≠ch chi ti·∫øt ·∫°! üíê";
    } else if (lowerMessage.includes('chƒÉm s√≥c') || lowerMessage.includes('cham soc')) {
      return baseResponse + " H·∫° Mi√™n s·∫Ω h∆∞·ªõng d·∫´n c√°ch b·∫£o qu·∫£n hoa ƒë·ªÉ t∆∞∆°i l√¢u ·∫°! üå∏";
    }
    
    return baseResponse;
  }

  // Get conversation suggestions from Dialogflow
  getDialogflowSuggestions(intent) {
    if (this.dialogflowLoader && this.dialogflowLoader.loaded) {
      return this.dialogflowLoader.getConversationSuggestions(intent);
    }
    
    // Fallback to config suggestions
    const config = window.CHATBOT_CONFIG || {};
    return config.intentSuggestions?.[intent.name] || ['T∆∞ v·∫•n', 'ƒê·∫∑t hoa theo m·∫´u', 'Thi·∫øt k·∫ø theo y√™u c·∫ßu'];
  }

  // Extract entities from user input using Dialogflow
  extractDialogflowEntities(message) {
    if (this.dialogflowLoader && this.dialogflowLoader.loaded) {
      return this.dialogflowLoader.extractEntities(message);
    }
    return {};
  }

  // Show contextual suggestions with Dialogflow integration
  showContextualSuggestions() {
    const stage = this.conversationContext.conversationStage;
    const currentIntent = this.conversationContext.currentIntent;
    
    let suggestions = [];
    
    // Get suggestions from Dialogflow if available
    if (currentIntent && this.dialogflowLoader && this.dialogflowLoader.loaded) {
      suggestions = this.getDialogflowSuggestions(currentIntent);
    } else if (currentIntent && window.CHATBOT_CONFIG && window.CHATBOT_CONFIG.intentSuggestions) {
      suggestions = window.CHATBOT_CONFIG.intentSuggestions[currentIntent.name] || [];
    }
    
    if (suggestions.length === 0) {
      // Default suggestions based on stage
      const stageSuggestions = {
        'greeting': ['ƒê·∫∑t hoa theo m·∫´u', 'T∆∞ v·∫•n', 'Thi·∫øt k·∫ø theo y√™u c·∫ßu'],
        'browsing': ['Xem b·ªô s∆∞u t·∫≠p', 'T∆∞ v·∫•n lo·∫°i hoa', 'H·ªèi v·ªÅ √Ω nghƒ©a'],
        'ordering': ['ƒê·∫∑t hoa giao ngay', 'Thi·∫øt k·∫ø ri√™ng', 'H·ªèi v·ªÅ gi√°'],
        'support': ['H·ªèi v·ªÅ ƒë∆°n h√†ng', 'CSKH sau mua', 'Li√™n h·ªá hotline']
      };
      suggestions = stageSuggestions[stage] || window.CHATBOT_CONFIG?.chatbot?.suggestions || [];
    }
    
    // Add personalized suggestions based on conversation history
    suggestions = this.addPersonalizedSuggestions(suggestions);
    
    this.addSuggestions(suggestions);
  }
}

// Export for potential external use
if (typeof module !== 'undefined' && module.exports) {
  module.exports = HaMienChatbot;
}


